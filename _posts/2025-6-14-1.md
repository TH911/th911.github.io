# 卢卡斯定理 Lucas 定理

Lucas 定理用于求解大组合数取**质数模**。（对于模数不为质数的情况，请参考[exLucas 定理（扩展卢卡斯）](https://www.luogu.com.cn/problem/P4720)）。

Lucas 定理的内容很简单：

$$
\binom{n}{m}\equiv\binom{\lfloor\frac np\rfloor}{\lfloor\frac mp\rfloor}\binom{n\bmod p}{m\bmod p}\pmod p
$$

考虑如何证明。

## 证明

由二项式定理：

$$
(a+b)^p=\sum_{i=0}^p\binom pia^ib^{p-i}
$$

考虑 $\dbinom pi$ 在模 $p$ 意义下的取值。

因为：

$$
\dbinom pi=\dfrac{p!}{i!(p-i)!}
$$

那么如果化简之后，分子 $p!$ 中的 $p$ 项**没有**被约分掉，则有 $\dbinom pi\equiv p\cdot\dfrac{(p-1)!}{i!(p-i)!}\equiv0\pmod p$。

因为 $p$ 为质数，所以 $p$ 项能被约分掉当且仅当 $i!$ 中含有 $p$ 项或 $(p-i)!$ 中含有 $p$ 项。

即：$\dbinom pi\not\equiv0\pmod p$ 当且仅当 $i\equiv0\pmod p$ 或 $p-i\equiv 0\pmod p$。

在二项式定理中，$i$ 满足 $0\leq i\leq p$，所以 $\dbinom pi\not\equiv0$ 当且仅当 $i=0$ 或 $i=p$。

在这两种情况中，都可以计算得到 $\dbinom pi=1$，即 $\dbinom pi\equiv[i=0\lor i=p]$。

重新带回二项式定理，可得：
$$
\begin{aligned}
(a+b)^p&\equiv \dbinom{p}{0}a^0b^p+\dbinom ppa^pb^0\\
&\equiv a^p+b^p
\end{aligned}
\pmod p
$$

***

考虑一个二项式 $(1+x)^n\bmod p$。

$$
\begin{aligned}
(1+x)^n&\equiv (1+x)^{p\lfloor\frac np\rfloor+n\bmod p}\\
&\equiv(1+x)^{p\lfloor\frac np\rfloor}(1+x)^{n\bmod p}\\
&\equiv(1+x^p)^{\lfloor\frac np\rfloor}(1+x)^{n\bmod p}\\
\end{aligned}
\pmod p
$$

由二项式定理，$(1+x)^n$ 的 $x^m$ 项系数为 $\dbinom nm$。

而想要从 $(1+x^p)^{\lfloor\frac np\rfloor}(1+x)^{n\bmod p}$ 中得到 $x^m$，即从 $(1+x^p)^{\lfloor\frac np\rfloor}$ 中选取 $\lfloor\frac mp\rfloor$ 个 $x^p$，再从 $(1+x)^{n\bmod p}$ 中选取 $m\bmod p$ 个 $x$。

即：

$$
\dbinom nm\equiv\dbinom{\lfloor\frac np\rfloor}{\lfloor\frac mp\rfloor}\dbinom{n\bmod p}{m\bmod p}
\pmod p
$$

***

你可能有一个问题：这看起来明明应当是一个**等式**，但为什么是**同余**呢？

即，Lucas 定理应当表述为：
$$
\dbinom nm=\dbinom{\lfloor\frac np\rfloor}{\lfloor\frac mp\rfloor}\dbinom{n\bmod p}{m\bmod p}
$$
但是，你要知道，只有在模 $p$ 意义下才有 $(1+x)^{p\lfloor\frac np\rfloor}=(1+x^p)^{\lfloor\frac np\rfloor}$。

因此，只有在模 $p$ 意义下才有：

$$
\dbinom nm=\dbinom{\lfloor\frac np\rfloor}{\lfloor\frac mp\rfloor}\dbinom{n\bmod p}{m\bmod p}
$$

即：
$$
\dbinom nm\equiv\dbinom{\lfloor\frac np\rfloor}{\lfloor\frac mp\rfloor}\dbinom{n\bmod p}{m\bmod p}\pmod p
$$

## 应用

当 $n$ 比较大而无法使用其他方法（例如预处理 $1\sim n$ 的阶乘再利用乘法逆元）直接求解组合数时，可以使用 Lucas 定理。

Lucas 定理只需要递归使用即可，即递归计算 $\dbinom{\lfloor\frac np\rfloor}{\lfloor\frac mp\rfloor}$，递归终点即 $\dbinom{0}{0}$。

其时间复杂度为：$\mathcal O\left(f(p)\log m\right)$。

其中，$f(p)$ 表示单次计算 $\dbinom{n\bmod p}{m\bmod p}$ 的复杂度，因写法而异。

可以使用乘法逆元，则时间复杂度为 $\mathcal O(\log p\log m)$。

也可以 $\mathcal O(p\log p)$ 递推，时间复杂度为 $\mathcal O(p\log p\log m)$。

推荐使用乘法逆元。

# AC 代码

比较懒，写的 $\mathcal O(p\log p\log n)$。

```cpp
#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
const int N=1e5;
int ksm(int a,int n,int p){
	if(n==0)return 1;
	int t=ksm(a,n>>1,p);
	t=1ll*t*t%p;
	if(n&1)t=1ll*t*a%p;
	return t;
}
int C(int n,int m,int p){
	static int ans[N+1]={1};
	for(int i=1;i<=m;i++){
		ans[i]=1ll*ans[i-1]*(n-i+1)%p*ksm(i,p-2,p)%p;
	}return ans[m];
}
int Lucas(int n,int m,int p){
	if(m==0)return 1;
	return (1ll*Lucas(n/p,m/p,p)*C(n%p,m%p,p))%p;
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	int T,n,m,p;
	scanf("%d",&T);
	while(T--){
		scanf("%d %d %d",&n,&m,&p);
		printf("%d\n",Lucas(n+m,n,p));
	}
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

