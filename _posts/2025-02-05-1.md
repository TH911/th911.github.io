---
layout: post
title: "数论学习笔记"
subtitle: "同余 CRT exgcd BSGS Lucas"
date: 2025-2-5
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 题解
  - 数学
  - 提高+/省选−
  - 省选/NOI−
  - CRT
  - exCRT
  - exgcd
  - BSGS
  - exBSGS
  - Lucas
  - exLucas
  - 未完
words:
  - 求和求乘积
  - 和式
  - 级数
  - 同余
  - 模运算
  - 阶乘
  - 扩展欧几里得
  - NOIP2012
  - 艾弗森括号Iverson括号
  - Baby-Step Giant-Step大步小步算法BSGSexBSGS离散对数
  - Lucas定理 exLucas算法 扩展鲁卡瑟
  - 洛谷P1082洛谷PP1495洛谷P5656
  - 题解：[NOIP 2012 提高组] 同余方程
  - 题解：中国剩余定理（CRT）/ 曹冲养猪
  - 题解：【模板】中国剩余定理（CRT）/ 曹冲养猪
  - 题解：二元一次不定方程 (exgcd)
  - 题解：【模板】二元一次不定方程 (exgcd)
---

> [参考资料](/file/2025/02/math.pdf)

本文中出现的代数式、数，如无特殊说明，均为**整数**。

# 基础部分

# 质数

## Fermat 素性测试

由费马小定理，对于质数 $p$，若 $\gcd(a,p)=1$，满足 $a^{p-1}\equiv 1\pmod p$，$a^{p-2}\equiv a^{-1}\pmod p$。

但是 $a^{p-1}\equiv1\pmod p$ 并不能推出 $p$ 为质数。

因此可以随机选择来测试。

## Miller–Rabin 素性测试

Miller-Rabin 素性测试，取质数集合 $A=\lbrace{2,3,5,7,11,13,17,19,23,29,31,37}\rbrace$，则可以通过随机化确定 `long long` 范围（$[0,2^{64})$）内的任意整数 $n$ 是否为质数。

从 $A$ 中取一底数 $a$，若：

* $n=a$，$n$ 为质数。
* $n\bmod a=0\land n>a$，$n$ 不为质数。

在都不成立的情况下，进行 Miller-Rabin 素性测试。

将 $n-1$ 转化：

$$
n-1=d\times2^r
$$

其中，$d,r\in\N^*$，也就是说，$d$ 是 $n-1$ 在二进制位上的一个前缀，满足前缀的后缀不为 $0$。

### 二次探测定理

$$
x^2\equiv1\pmod p\\
\Downarrow\\
x\equiv\pm1\pmod p
$$

使用平方差公式可证。

### Miller-Rabin 素性测试的实现

基于 $a$ 执行 $r$ 轮测试，

### 参考代码

```cpp
constexpr const ll A[12]={2,3,5,7,11,13,17,19,23,29,31,37};
bool MillerRabin(ll n){
	if(n<=1){
		return false;
	}
	for(ll a:A){
		if(n==a){
			return true;
		}
		if(n%a==0){
			return false;
		}
		bool no=true;
		ll d=n-1,r=0;
		while(!(d&1)){
			r++;
			d>>=1;
		}
		ll pl=qpow(a,d,n);
		if(pl==1){
			no=false;
		}
		for(int i=0;no&&i<r;i++){
			if(pl==n-1){
				no=false;
			}
			pl=(__int128)pl*pl%n;
		}
		if(no){
			return false;
		}
	}
	return true;
}
```

# 最大公约数

## 裴蜀定理

对于 $\forall a,b\in \Z$：

* $\exist x,y\in \Z$，使 $ax+by=\gcd(a,b)$。

* $\forall x,y\in\Z$，$\gcd(a,b)\mid(ax+by)$。

### 逆定理

$\forall a,b\in \Z$，若 $d>0$ 且 $d$ 为 $a,b$ 的公因数，且存在 $x,y$，使得 $ax+by=d$，则：
$$
d=\gcd(a,b)
$$


# 乘法逆元

若存在 $ax\equiv 1\pmod p$，则称 $x$ 为 $a$ 关于 $p$ 的逆元，记 $x=a^{-1}$。

当 $\gcd(a,p)=1$ 的时候（$p$ 为质数）逆元**一定存在**。

## 费马小定理

对于质数 $p$，若 $\gcd(a,p)=1$，满足 $a^{p-1}\equiv 1\pmod p$，$a^{p-2}\equiv a^{-1}\pmod p$。

常用于分数取模，即：

$$
\frac{a}{b}\equiv ab^{p-2}\pmod p
$$

详见[费马小定理](/2024/11/27/1/)。

## 欧拉定理

<details class="info">
    <summary>欧拉函数</summary>
    <p>
        记 $\varphi(n)$ 为 $1\sim n$ 中与 $n$ 互质的数的个数。
    </p>
    <p>
        令 $n=p_1^{c_1}p_2^{c_2}p_3^{c_3}\cdots p_k^{c_k}$，满足 $p_i$ 为质数，$c_i>0$。
    </p>
    <p>
        则：
    </p>
    <p>
        $$
        \varphi(n)=n\left(1-\frac 1{p_1}\right)\left(1-\frac 1{p_2}\right)\left(1-\frac 1{p_3}\right)\cdots\left(1-\frac 1{p_k}\right)
        $$
    </p>
    <p>
        推导见<a href="/2025/02/04/2/#求解欧拉函数-varphin">容斥原理求解欧拉函数</a>。
    </p>
</details>

若 $\gcd(a,p)=1$，则 $a^{\varphi(p)}\equiv1\pmod p$。

显然，当 $p$ 为质数时，有 $\varphi(p)=p-1$，即费马小定理。因此，**费马小定理为欧拉定理的特殊形式**。

## 扩展欧拉定理

对于任意的 $a,p,b\in \N^*$，若满足 $\gcd(a,p)>1,b\geq \varphi(p)$，有：

$$
a^b\equiv a^{b\bmod \varphi(p)+\varphi(p)}\pmod p
$$

当 $\gcd(a,p)=1$ 时即欧拉定理。

可以使用初等证明或群论证明。

常用于降幂。

## 扩展欧几里得算法 exgcd

**注意不是“类欧几里得算法”。**

用于求关于 $x,y$ 的不定方程 $ax+by=\gcd(a,b)$ 的**一组整数特解**。

不妨令 $a>b$。

考虑到 $a=\left\lfloor\dfrac{a}{b}\right\rfloor b+a\bmod b$，代入可得：

$$
\left(\left\lfloor\frac{a}{b}\right\rfloor b+a\bmod b\right)x+by=\gcd(a,b)
$$

因此：

$$
b\left(\left\lfloor\frac ab\right\rfloor x+y\right)+(a\bmod b)x=\gcd(b,a\bmod b)
$$

令 $a'=b,x'=\left\lfloor\dfrac ab\right\rfloor x+y,b'=a\bmod b,y'=x$，有：

$$
a'x'+b'y'=\gcd(a',b')
$$

显然，可以**递归求解**。

那么直到 $b=0$ 时，可以直接解得一组整数特解 $$\begin{cases}x=1\\y=0\end{cases}$$。

设最终递归出来的解为 $$\begin{cases}x=x_0\\y=y_0\end{cases}$$

令 $\Delta b=\dfrac{b}{\gcd(a,b)},\Delta a=\dfrac{a}{\gcd(a,b)}$，则对于 $\forall k\in \N^*$，方程存在一组解为 $$\begin{cases}x=x_0+k\Delta b\\y=y_0-k\Delta a\end{cases}$$。

### 参考代码

```cpp
void exgcd(int a,int &x,int b,int &y){
	if(!b){
		x=1;
		y=0;
		return;
	}
	int tmp;
	exgcd(b,tmp,a%b,x);
	y=tmp-a/b*x;
}
```

### exgcd 求乘法逆元

如果需要讨论 $a$ 模 $p$ 意义下的乘法逆元 $a^{-1}$，显然有 $\gcd(a,p)=1$。

那么可列方程 $ax+py=1$，显然 $ax\equiv1\pmod p$。

则通过扩展欧几里得算法求出 $x$，即求出了 $a$ 的逆元。

> [例题链接：[NOIP 2012] 同余方程](https://www.luogu.com.cn/problem/P1082)

求出 $x$ 后，为了使 $x$ 为正整数，只需要让 $x\leftarrow(x\bmod p+p)\bmod p$ 即可。

<details class="success">
    <summary>参考代码</summary>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><div class="table-responsive"><table class="rouge-table table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="c1">//#include&lt;bits/stdc++.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstring&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;ctime&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;deque&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;list&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">exgcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">){</span>
		<span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">exgcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">tmp</span><span class="p">,</span><span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
	<span class="n">y</span><span class="o">=</span><span class="n">tmp</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="cm">/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/</span>

	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	
	<span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">a</span><span class="o">&gt;&gt;</span><span class="n">b</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">x0</span><span class="p">,</span><span class="n">y0</span><span class="p">;</span>
	<span class="n">exgcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x0</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">y0</span><span class="p">);</span>
	<span class="n">x0</span><span class="o">%=</span><span class="n">b</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">x0</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
		<span class="n">x0</span><span class="o">+=</span><span class="n">b</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x0</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
	
	<span class="n">cout</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
	 
	<span class="cm">/*fclose(stdin);
	fclose(stdout);*/</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></div></code></pre></div></div>
</details>

### 例题：正整数最大/小解

> [例题链接](https://www.luogu.com.cn/problem/P5656)
>
> 给定不定方程 $ax+by=c$，$a,b,c\in \N^*$，判断其是否有解。
>
> 若有正整数解，分别求 $x,y$ 的最大/小值。
>
> 否则，求 $x,y$ 得最小正整数解。

对于无解，即 $\gcd(a,b)\nmid c$，很好判断。

先通过 exgcd 求出一组特解 $(x_0,y_0)$，则 $$\begin{cases}x=x_0+k\Delta b\\y=y_0-k\Delta a\end{cases}$$ 也是原方程得解。

先求 $x$ 的最小正整数解 $x_{\min}$，即 $x_0+k\Delta b$ 最小，显然 $x_{\min}=x_0\bmod \Delta b$。

但是为了保证 $x_{\min}$ 为正整数，因此当 $x_0\bmod \Delta b\leq0$ 时，$x_{\min}=x_0\bmod \Delta b+\Delta b$。

$a,b>0$，因此 $x$ 最小时 $y$ 最大，因此可以确定 $y_{\max}=\dfrac{c-ax_{\min}}{b}$。

同理，可求出 $x_{\max},y_{\min}$。

当 $x_{\min}$ 为**正整数**，此时若 $y_{\max}>0$，则存在正整数解 $$\begin{cases}x=x_{\min}\\y=y_{\max}\end{cases}$$，因此可以判断正整数解（判断 $x_{\max}>0$ 也行）。

正整数解的个数即：

$$
\frac{x_{\max}-x_{\min}}{\Delta b}+1
$$

因为从 $x_{\min}$ 开始，$x_{\min}+k\Delta b$ 对应一组 $x,y$。

<details class="success">
    <summary>参考代码</summary>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><div class="table-responsive"><table class="rouge-table table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
</pre></td><td class="rouge-code"><pre><span class="c1">//#include&lt;bits/stdc++.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstring&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;ctime&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;deque&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;list&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#define int ll
</span><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
	<span class="k">while</span><span class="p">(</span><span class="n">b</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">tmp</span><span class="o">=</span><span class="n">a</span><span class="p">;</span>
		<span class="n">a</span><span class="o">=</span><span class="n">b</span><span class="p">;</span>
		<span class="n">b</span><span class="o">=</span><span class="n">tmp</span><span class="o">%</span><span class="n">b</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">exgcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">){</span>
		<span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">exgcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">tmp</span><span class="p">,</span><span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
	<span class="n">y</span><span class="o">=</span><span class="n">tmp</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">main</span><span class="p">(){</span>
	<span class="cm">/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/</span>

	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	
	<span class="kt">int</span> <span class="n">T</span><span class="p">;</span>
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">T</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">T</span><span class="o">--</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">;</span>
		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">a</span><span class="o">&gt;&gt;</span><span class="n">b</span><span class="o">&gt;&gt;</span><span class="n">c</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">gcdAB</span><span class="o">=</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">%</span><span class="n">gcdAB</span><span class="p">){</span>
			<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"-1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
		<span class="p">}</span><span class="k">else</span><span class="p">{</span>
			<span class="kt">int</span> <span class="n">w</span><span class="o">=</span><span class="n">c</span><span class="o">/</span><span class="n">gcdAB</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">x0</span><span class="p">,</span><span class="n">y0</span><span class="p">;</span>
			<span class="n">exgcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x0</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">y0</span><span class="p">);</span>
			<span class="n">x0</span><span class="o">*=</span><span class="n">w</span><span class="p">,</span><span class="n">y0</span><span class="o">*=</span><span class="n">w</span><span class="p">;</span>
<span class="c1">//			cerr&lt;&lt;"x0="&lt;&lt;x0&lt;&lt;" y0="&lt;&lt;y0&lt;&lt;endl;</span>
			<span class="kt">int</span> <span class="n">xMin</span><span class="p">,</span><span class="n">xMax</span><span class="p">,</span><span class="n">yMin</span><span class="p">,</span><span class="n">yMax</span><span class="p">;</span>
			
			<span class="kt">int</span> <span class="n">deltaA</span><span class="o">=</span><span class="n">a</span><span class="o">/</span><span class="n">gcdAB</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">deltaB</span><span class="o">=</span><span class="n">b</span><span class="o">/</span><span class="n">gcdAB</span><span class="p">;</span>
			
			<span class="n">xMin</span><span class="o">=</span><span class="n">x0</span><span class="o">%</span><span class="n">deltaB</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">xMin</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">){</span>
				<span class="n">xMin</span><span class="o">+=</span><span class="n">deltaB</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">yMax</span><span class="o">=</span><span class="p">(</span><span class="n">c</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">xMin</span><span class="p">)</span><span class="o">/</span><span class="n">b</span><span class="p">;</span>
			
			<span class="n">yMin</span><span class="o">=</span><span class="n">y0</span><span class="o">%</span><span class="n">deltaA</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">yMin</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">){</span>
				<span class="n">yMin</span><span class="o">+=</span><span class="n">deltaA</span><span class="p">;</span>
			<span class="p">}</span> 
			<span class="n">xMax</span><span class="o">=</span><span class="p">(</span><span class="n">c</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">yMin</span><span class="p">)</span><span class="o">/</span><span class="n">a</span><span class="p">;</span>

<span class="c1">//			cerr&lt;&lt;"A="&lt;&lt;a&lt;&lt;" B="&lt;&lt;b&lt;&lt;endl;</span>
<span class="c1">//			cerr&lt;&lt;"ΔA="&lt;&lt;deltaA&lt;&lt;" ΔB="&lt;&lt;deltaB&lt;&lt;endl;</span>
<span class="c1">//			cerr&lt;&lt;"xMax="&lt;&lt;xMax&lt;&lt;" xMin="&lt;&lt;xMin&lt;&lt;" yMax="&lt;&lt;yMax&lt;&lt;" yMin="&lt;&lt;yMin&lt;&lt;endl;</span>
			
			<span class="k">if</span><span class="p">(</span><span class="n">yMax</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
				<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">xMax</span><span class="o">-</span><span class="n">xMin</span><span class="p">)</span><span class="o">/</span><span class="n">deltaB</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="o">&lt;&lt;</span><span class="n">xMin</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="o">&lt;&lt;</span><span class="n">yMin</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="o">&lt;&lt;</span><span class="n">xMax</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="o">&lt;&lt;</span><span class="n">yMax</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span> 
			<span class="p">}</span><span class="k">else</span><span class="p">{</span>
				<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">xMin</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="o">&lt;&lt;</span><span class="n">yMin</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span> 
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="n">cout</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
	
	<span class="cm">/*fclose(stdin);
	fclose(stdout);*/</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
1
3 18 6

2 1 
*/</span> 
</pre></td></tr></tbody></table></div></code></pre></div></div>
</details>

## 线性求逆元

有一种方法，可以在 $\mathcal O(\log V+n)$ 的时间内求出任意 $n$ 个数 $a_1,a_2,\cdots,a_n$ 关于 $p$ 的逆元。

记：

$$
\textit{pre}_i\equiv\prod_{j=1}^ia_j\pmod p
$$

那么就可以 $\mathcal O\left(\log V\right)$ 计算：

$$
\textit{preinv}_{n}\equiv\frac{1}{\textit{pre}_n}\pmod p
$$

$n-1\sim 1$ 递推，可以推出：

$$
\textit{preinv}_i\equiv\frac{1}{\textit{pre}_i}\equiv\frac{1}{\textit{pre}_{i+1} }\cdot a_{i+1}\pmod p
$$

随后再次递推，可以得到 $a_i$ 关于 $p$ 的逆元 $\textit{inv}_i$：

$$
\textit{inv}_i\equiv\textit{preinv}_i\cdot\textit{pre}_{i-1}\pmod p
$$

### 参考代码

```cpp
pre[0]=1;
for(int i=1;i<=n;i++){
    pre[i]=1ll*pre[i-1]*a[i]%P;
}
inv[n]=qpow(pre[n],P-2);
for(int i=n-1;i>=1;i--){
    inv[i]=1ll*inv[i+1]*(a[i+1])%P;
}
for(int i=1;i<=n;i++){
    inv[i]=1ll*inv[i]*pre[i-1]%P;
}
```



# CRT 中国剩余定理

<details class="tips" open>
    <summary>CRT 中的运算溢出</summary>
    <p>
        <b>在使用 CRT 或 exCRT 时，一律建议使用 <code>__int128</code>，防止溢出</b>。
    </p>
    <p>
        尽管题目大多会保证 $\operatorname{lcm}(p_1,p_2,\cdots,p_n)\leq10^{18}$，但是中间计算时会溢出。
    </p>
</details>

CRT（中国剩余定理）被用于求解线性同余方程组：

$$
\begin{cases}
x\equiv a_1\pmod{p_1}\\
x\equiv a_2\pmod{p_2}\\
\cdots\\
x\equiv a_n\pmod{p_n}
\end{cases}
$$

其中，$p_1,p_2,p_3,\cdots,p_n$ **两两互质**。

***

令 $L=\prod\limits_{i=1}^np_i$，则对于 $k\in\N$ 有 $k\cdot L\equiv0\pmod{p_i}$。

记 $q_i=\dfrac{L}{p_i}$，设 $c_i\equiv q_i^{-1}\pmod{p_i}$，即 $q_i$ 模 $p_i$ 意义下的逆元。

则，方程组的**最小**整数解为：

$$
x=\left(\sum_{i=1}^na_iq_ic_i\right)\bmod L
$$

同时，对于 $\forall k\in\N^*$，$x+kL$ 均为原方程组的解。

***

CRT 其实就是一个**构造式**的做法，易证 $\forall i\neq j,a_iq_ic_i\equiv0\pmod{p_j}$。

## 例题：[中国剩余定理（CRT）/ 曹冲养猪](https://www.luogu.com.cn/problem/P1495)

题目中的 $a_i,b_i$ 即分别为 $p_i,a_i$。

直接套 CRT 即可，但是需要注意的是，计算 $a_iq_ic_i$ 时需要 `__int128`，会爆 `long long`。

<details class="success">
    <summary>参考代码</summary>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><div class="table-responsive"><table class="rouge-table table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre></td><td class="rouge-code"><pre><span class="c1">//#include&lt;bits/stdc++.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstring&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;ctime&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;deque&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;list&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">exgcd</span><span class="p">(</span><span class="n">ll</span> <span class="n">a</span><span class="p">,</span><span class="n">ll</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="n">ll</span> <span class="n">b</span><span class="p">,</span><span class="n">ll</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">){</span>
		<span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ll</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">exgcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">tmp</span><span class="p">,</span><span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
	<span class="n">y</span><span class="o">=</span><span class="n">tmp</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">ll</span> <span class="nf">inverse</span><span class="p">(</span><span class="n">ll</span> <span class="n">a</span><span class="p">,</span><span class="n">ll</span> <span class="n">p</span><span class="p">){</span>
	<span class="n">ll</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
	<span class="n">exgcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
	<span class="n">x</span><span class="o">%=</span><span class="n">p</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
		<span class="n">x</span><span class="o">+=</span><span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="cm">/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/</span>

	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="p">;</span>
	<span class="n">ll</span> <span class="n">L</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> 
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">L</span><span class="o">*=</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">ll</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">ll</span> <span class="n">q</span><span class="o">=</span><span class="n">L</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="n">inverse</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">x</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="p">(</span><span class="n">__int128</span><span class="p">)</span><span class="mi">1</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">%</span><span class="n">L</span><span class="o">*</span><span class="n">q</span><span class="o">%</span><span class="n">L</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">%</span><span class="n">L</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
		<span class="n">x</span><span class="o">+=</span><span class="n">L</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
	
	<span class="n">cout</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
	 
	<span class="cm">/*fclose(stdin);
	fclose(stdout);*/</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></div></code></pre></div></div>
</details>

## 扩展 CRT/exCRT

> [例题链接](https://www.luogu.com.cn/problem/P4777)

exCRT 实际上与 CRT 关系不大，如同 exLucas 与 Lucas 一般。

exCRT 解决的是当模数 $p_1,p_2,p_3,\cdots,p_n$ **不一定两两互质**的时候（这时有可能无解）。

先考虑两个**同余方程**：

$$
\begin{cases}
x\equiv a_1\pmod{p_1}\\
x\equiv a_2\pmod{p_2}\\
\end{cases}
$$

设 $r,s$，将其转化为两个**不定方程**：

$$
\begin{cases}
x=a_1+r\cdot p_1\\
x=a_2+s\cdot p_2\\
\end{cases}
$$

因此可得 $r\cdot p_1-s\cdot p_2=a_2-a_1$。

由[裴蜀定理](#裴蜀定理)，若 $(a_2-a_1)\nmid\gcd(p_1,-p_2)$，则该不定方程**无解**，则**原同余方程组无解**。

否则通过 exgcd 求出 $r,s$，则：

$$
x=a_1+r\cdot p_1=a_2+s\cdot p_2
$$

既然 $x=a_1+r\cdot p_1$，因此有：

$$
x\equiv a_1+r\cdot p_1\pmod{\operatorname{lcm}(p_1,p_2)}
$$

这样取 $\operatorname{lcm}(p_1,p_2)$ 是为了将两个方程合并。

这样，两两顺次合并，**最终合并为一个方程**即可解。

### 参考代码

```cpp
for(int i=2;i<=n;i++){
    ll w=(a[i]-a[i-1])/gcd(p[i-1],-p[i]);
    ll r,s;
    exgcd(p[i-1],r,-p[i],s);
    r*=w,s*=w;
    a[i]=(p[i-1]*r+a[i-1])%lcm(p[i-1],p[i]);
    p[i]=lcm(p[i-1],p[i]);
    if(i==n){
        if(a[n]<0){
            a[n]+=p[n];
        }
        cout<<a[n]<<'\n';
    }
}
```

<details class="success">
    <summary>例题参考代码</summary>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><div class="table-responsive"><table class="rouge-table table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
</pre></td><td class="rouge-code"><pre><span class="c1">//#include&lt;bits/stdc++.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstring&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;ctime&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;deque&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;list&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">IO</span><span class="p">{</span>
	<span class="kr">inline</span> <span class="kt">char</span> <span class="n">getchar</span><span class="p">(){</span>
		<span class="k">static</span> <span class="kt">int</span> <span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">;</span>
		<span class="k">static</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">];</span>
		<span class="k">if</span><span class="p">(</span><span class="n">p1</span><span class="o">==</span><span class="n">p2</span><span class="p">)</span><span class="n">p2</span><span class="o">=</span><span class="n">fread</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">,</span><span class="n">stdin</span><span class="p">),</span><span class="n">p1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">p1</span><span class="o">==</span><span class="n">p2</span><span class="o">?</span><span class="n">EOF</span><span class="o">:</span><span class="n">buf</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
	<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">scanf</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">){</span>
		<span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">register</span> <span class="kt">int</span> <span class="n">f</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">register</span> <span class="kt">char</span> <span class="n">ch</span><span class="o">=</span><span class="n">IO</span><span class="o">::</span><span class="n">getchar</span><span class="p">();</span>
		<span class="k">for</span><span class="p">(;</span><span class="n">ch</span><span class="o">&lt;</span><span class="sc">'0'</span><span class="o">||</span><span class="sc">'9'</span><span class="o">&lt;</span><span class="n">ch</span><span class="p">;</span><span class="n">ch</span><span class="o">=</span><span class="n">IO</span><span class="o">::</span><span class="n">getchar</span><span class="p">());</span>
		<span class="k">for</span><span class="p">(;</span><span class="sc">'0'</span><span class="o">&lt;=</span><span class="n">ch</span><span class="o">&amp;&amp;</span><span class="n">ch</span><span class="o">&lt;=</span><span class="sc">'9'</span><span class="p">;</span><span class="n">ch</span><span class="o">=</span><span class="n">IO</span><span class="o">::</span><span class="n">getchar</span><span class="p">())</span><span class="n">x</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">ch</span><span class="o">-</span><span class="sc">'0'</span><span class="p">;</span>
		<span class="n">x</span><span class="o">*=</span><span class="n">f</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">pbuf</span><span class="p">[</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">];</span>
	<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">putchar</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span><span class="p">){</span>
		<span class="n">pbuf</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">ch</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">)){</span>
			<span class="n">fwrite</span><span class="p">(</span><span class="n">pbuf</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">,</span><span class="n">stdout</span><span class="p">);</span>
			<span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
	<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">printf</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">){</span>
		<span class="k">static</span> <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">top</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">do</span><span class="p">{</span>
			<span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">top</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="o">%</span><span class="mi">10</span><span class="o">+</span><span class="sc">'0'</span><span class="p">;</span>
			<span class="n">x</span><span class="o">/=</span><span class="mi">10</span><span class="p">;</span>
		<span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
		<span class="k">while</span><span class="p">(</span><span class="n">top</span><span class="p">)</span><span class="n">IO</span><span class="o">::</span><span class="n">putchar</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">top</span><span class="o">--</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">end</span><span class="p">(){</span>
		<span class="n">fwrite</span><span class="p">(</span><span class="n">pbuf</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">stdout</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">struct</span> <span class="nc">Tool</span><span class="p">{</span>
		<span class="o">~</span><span class="n">Tool</span><span class="p">(){</span>
			<span class="n">end</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span><span class="n">tool</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">typedef</span> <span class="n">__int128</span> <span class="n">lll</span><span class="p">;</span>
<span class="cp">#define int lll
#define ll lll
</span><span class="c1">//typedef long long ll;</span>
<span class="k">constexpr</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span><span class="o">=</span><span class="mf">1e5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="n">ll</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">exgcd</span><span class="p">(</span><span class="n">ll</span> <span class="n">a</span><span class="p">,</span><span class="n">ll</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="n">ll</span> <span class="n">b</span><span class="p">,</span><span class="n">ll</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">){</span>
		<span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ll</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">exgcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">tmp</span><span class="p">,</span><span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
	<span class="n">y</span><span class="o">=</span><span class="n">tmp</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">ll</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">ll</span> <span class="n">a</span><span class="p">,</span><span class="n">ll</span> <span class="n">b</span><span class="p">){</span>
	<span class="k">while</span><span class="p">(</span><span class="n">b</span><span class="p">){</span>
		<span class="n">ll</span> <span class="n">tmp</span><span class="o">=</span><span class="n">a</span><span class="p">;</span>
		<span class="n">a</span><span class="o">=</span><span class="n">b</span><span class="p">;</span>
		<span class="n">b</span><span class="o">=</span><span class="n">tmp</span><span class="o">%</span><span class="n">b</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">ll</span> <span class="nf">lcm</span><span class="p">(</span><span class="n">ll</span> <span class="n">a</span><span class="p">,</span><span class="n">ll</span> <span class="n">b</span><span class="p">){</span>
	<span class="k">return</span> <span class="n">a</span><span class="o">/</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">main</span><span class="p">(){</span>
	<span class="cm">/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/</span>

	<span class="cm">/*ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);*/</span>
	
	<span class="n">IO</span><span class="o">::</span><span class="n">scanf</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="c1">//	cin&gt;&gt;n;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">IO</span><span class="o">::</span><span class="n">scanf</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">IO</span><span class="o">::</span><span class="n">scanf</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="c1">//		cin&gt;&gt;p[i]&gt;&gt;a[i];</span>
	<span class="p">}</span>
	<span class="c1">//合并(i-1,i) </span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="c1">//		cerr&lt;&lt;"------------------\nmerge("&lt;&lt;i-1&lt;&lt;","&lt;&lt;i&lt;&lt;")\n";</span>
		<span class="n">ll</span> <span class="n">w</span><span class="o">=</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">gcd</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="c1">//		cerr&lt;&lt;"w="&lt;&lt;a[i]-a[i-1]&lt;&lt;" / "&lt;&lt;gcd(p[i-1],-p[i])&lt;&lt;endl;</span>
		<span class="n">ll</span> <span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">;</span>
		<span class="n">exgcd</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">r</span><span class="p">,</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">s</span><span class="p">);</span>
		<span class="n">r</span><span class="o">*=</span><span class="n">w</span><span class="p">,</span><span class="n">s</span><span class="o">*=</span><span class="n">w</span><span class="p">;</span>
<span class="c1">//		cerr&lt;&lt;"r="&lt;&lt;r&lt;&lt;" s="&lt;&lt;s&lt;&lt;endl;</span>
<span class="c1">//		cerr&lt;&lt;"::A="&lt;&lt;p[i-1]*r+a[i-1]&lt;&lt;"\n::B="&lt;&lt;p[i]*s+a[i]&lt;&lt;endl;</span>
		<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">r</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">%</span><span class="n">lcm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">lcm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="c1">//		cerr&lt;&lt;"x≡"&lt;&lt;a[i]&lt;&lt;"(mod "&lt;&lt;p[i]&lt;&lt;")\n";</span>
		<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">n</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
				<span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">+=</span><span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="n">IO</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
<span class="c1">//			cout&lt;&lt;a[n]&lt;&lt;'\n';</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="n">cout</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
	
	<span class="cm">/*fclose(stdin);
	fclose(stdout);*/</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></div></code></pre></div></div>
</details>

# 离散对数

所谓离散对数，即模意义下取对数。

形如：给定模数 $p$，及**整数** $a,b$，求**整数** $x$ 使得 $a^x\equiv b\pmod p$。

**注意：离散对数可能不存在**。

## BSGS 算法

在 OI 中，BSGS 算法（Baby-Step Giant-Step，大步小步算法）常用来求解离散对数。

BSGS 算法要求 $a\perp p$，求 $x$ 使得 $a^x\equiv b\pmod p$。

若有解，则存在 $x\leq\varphi(p)$ 的解；因为[欧拉定理](#欧拉定理)说明，$a\perp p$ 时，$a^{\varphi(p)}\equiv1\pmod p$。

若枚举 $x$ 是 $\mathcal O(\varphi(p))$ 的，当 $p$ 为质数的时候**不能接受**，因此可以考虑分块。

令 $B=\left\lceil\sqrt{\varphi(p)}\right\rceil$，$x=qB+r$，且 $0\leq q,r\leq B$。

则有：

$$
a^{qB+r}\equiv b\pmod p
$$

$a\perp p$，则 $a$ 的乘法逆元 $a^{-1}$ 一定存在，有：

$$
a^{qB}\equiv b\left(a^{-1}\right)^r\pmod p
$$

枚举 $r$，将其与其对应的 $b\left(a^{-1}\right)^r$ 一同存储在数据结构（一般是哈希表）中，随后枚举 $q$，在数据结构中找 $a^{qB}$ 对应的 $r$，找到了 $r$ 便找到了一个解 $x=qB+r$。同时，因为 $a\perp p$，因此 $a^{-1},a^{-2},a^{-3},\cdots,a^{-B}$ 模 $p$ 意义下**互不相同**。

时间复杂度：$\mathcal O\left(\sqrt{\varphi(p)}\right)$，在 $p$ 为质数时最劣，$\mathcal O\left(\sqrt p\right)$。

### 参考代码

```cpp
B=ceil(sqrt(euler(P)));
c=qpow(a,B);
for(int r=0,powR=1,R=qpow(a,P-2);r<B;r++){
    m[1ll*b*powR%P]=r;
    powR=1ll*powR*R%P;
}
for(int q=0,powC=1;q<=B;q++){
    if(m.count(powC)){
        cout<<q*B+m[powC]<<endl;
        return 0;
    }
    powC=1ll*powC*c%P;
}
cout<<"no solution\n";
```

> [例题链接](https://www.luogu.com.cn/problem/P3846)

<details class="success">
    <summary>参考代码</summary>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><div class="table-responsive"><table class="rouge-table table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
</pre></td><td class="rouge-code"><pre><span class="c1">//#include&lt;bits/stdc++.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstring&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;ctime&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;deque&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;list&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">c</span><span class="p">;</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">euler</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="mi">1ll</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
			<span class="n">ans</span><span class="o">=</span><span class="n">ans</span><span class="o">/</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
				<span class="n">n</span><span class="o">/=</span><span class="n">i</span><span class="p">;</span> 
			<span class="p">}</span> 
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">){</span>
		<span class="n">ans</span><span class="o">=</span><span class="n">ans</span><span class="o">/</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> 
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">qpow</span><span class="p">(</span><span class="kt">int</span> <span class="n">base</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">){</span>
			<span class="n">ans</span><span class="o">=</span><span class="mi">1ll</span><span class="o">*</span><span class="n">ans</span><span class="o">*</span><span class="n">base</span><span class="o">%</span><span class="n">P</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">base</span><span class="o">=</span><span class="mi">1ll</span><span class="o">*</span><span class="n">base</span><span class="o">*</span><span class="n">base</span><span class="o">%</span><span class="n">P</span><span class="p">;</span>
		<span class="n">n</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="cm">/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/</span>

	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">P</span><span class="o">&gt;&gt;</span><span class="n">a</span><span class="o">&gt;&gt;</span><span class="n">b</span><span class="p">;</span>
	<span class="n">B</span><span class="o">=</span><span class="n">ceil</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">euler</span><span class="p">(</span><span class="n">P</span><span class="p">)));</span>
	<span class="n">c</span><span class="o">=</span><span class="n">qpow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">B</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">powR</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">R</span><span class="o">=</span><span class="n">qpow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">P</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span><span class="n">r</span><span class="o">&lt;</span><span class="n">B</span><span class="p">;</span><span class="n">r</span><span class="o">++</span><span class="p">){</span>
		<span class="n">m</span><span class="p">[</span><span class="mi">1ll</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">powR</span><span class="o">%</span><span class="n">P</span><span class="p">]</span><span class="o">=</span><span class="n">r</span><span class="p">;</span>
		<span class="n">powR</span><span class="o">=</span><span class="mi">1ll</span><span class="o">*</span><span class="n">powR</span><span class="o">*</span><span class="n">R</span><span class="o">%</span><span class="n">P</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">q</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">powC</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">q</span><span class="o">&lt;=</span><span class="n">B</span><span class="p">;</span><span class="n">q</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">powC</span><span class="p">)){</span>
			<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">q</span><span class="o">*</span><span class="n">B</span><span class="o">+</span><span class="n">m</span><span class="p">[</span><span class="n">powC</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">powC</span><span class="o">=</span><span class="mi">1ll</span><span class="o">*</span><span class="n">powC</span><span class="o">*</span><span class="n">c</span><span class="o">%</span><span class="n">P</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"no solution</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	
	<span class="n">cout</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
	
	<span class="cm">/*fclose(stdin);
	fclose(stdout);*/</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></div></code></pre></div></div>
</details>

## exBSGS 扩展 BSGS 算法

exBSGS 可解决 $a\perp p$ 不成立的情况。

由[扩展欧拉定理](#扩展欧拉定理)可知，若 $x$ 有解，则 $x\leq2\varphi(p)$ 范围内也有解。

首先特判掉 $x=0$ 的情况，即 $b=1$ 或 $p=1$。

考虑分块，令 $B=\left\lceil\sqrt{2\varphi(p)}\right\rceil,x=qB-r,0\leq q,r\leq B$，则有：
$$
a^{qB-r}\equiv b\pmod p\\
\Downarrow\\
a^{qB}\equiv b\cdot a^r\pmod p
$$

因此可以预处理 $a^{qB}\bmod p$，随后枚举 $r$；但是注意到前者是后者的**充分条件而不是充要条件**，因此找出来的 $x=qB+r$ 只是“**可能的解**”，**需要检验**。

对于多个不同的 $q$ 产生的模 $p$ 意义下相同的 $a^{qB}$，可以只存储 **$q$ 最小的**两个。

<details class="note">
    <summary>证明</summary>
    <p>
        由<a href="#扩展欧拉定理">扩展欧拉定理</a>，$a^x$ 是在 $k\leq\varphi(p)$ 值后以 $\varphi(p)$ 为周期循环的。
    </p>
    <p>
        循环周期内的 $a^{qB}$ 显然至多存储 $1$ 个，而非循环部分 $a^{qB}$ 也至多存储 $1$ 个。
    </p>
    <p>
        即：保留最小的 $2$ 个。
    </p>
</details>

时间复杂度：仍然为 $\mathcal O\left(\sqrt{\varphi(p)}\right)$。

### 参考代码

```cpp
a%=P;b%=P;
if(b==1||P==1){
    cout<<"0\n";
    continue;
}
B=ceil(2*sqrt(euler(P)));
c=qpow(a,B);
for(int q=0,powC=1;q<B;q++){
    auto &pl=m[powC];
    if(pl.size()<2){
        pl.push_back(q);
    } 
    powC=1ll*c*powC%P;
}
int x=2147483647;
for(int r=0,powA=1;r<B;r++){
    auto &pl=m[1ll*b*powA%P];
    for(int q:pl){
        int x0=(1ll*q*B-r)%P;
        if(x0<0){
            continue;
        } 
        if(qpow(a,x0)==b){
            x=min(x,x0);
        }
    }
    powA=1ll*powA*a%P;
}
if(x<2147483647){
    cout<<x<<'\n';
}else{
    cout<<"No Solution\n";
}
```


> [例题链接](https://www.luogu.com.cn/problem/P4195)

<details class="success">
    <summary>参考代码</summary>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><div class="table-responsive"><table class="rouge-table table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
</pre></td><td class="rouge-code"><pre><span class="c1">//#include&lt;bits/stdc++.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstring&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;ctime&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;deque&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;list&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;ext/pb_ds/assoc_container.hpp&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;ext/pb_ds/tree_policy.hpp&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">c</span><span class="p">;</span>
<span class="c1">//pb_ds 哈希表常数较 unordered_map 更小</span>
<span class="n">__gnu_pbds</span><span class="o">::</span><span class="n">gp_hash_table</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="n">m</span><span class="p">;</span>
<span class="c1">//unordered_map&lt;int,vector&lt;int&gt; &gt;m;</span>
<span class="c1">//map&lt;int,vector&lt;int&gt; &gt;m;</span>
<span class="kt">int</span> <span class="nf">euler</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="mi">1ll</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
			<span class="n">ans</span><span class="o">=</span><span class="n">ans</span><span class="o">/</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
				<span class="n">n</span><span class="o">/=</span><span class="n">i</span><span class="p">;</span> 
			<span class="p">}</span> 
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">){</span>
		<span class="n">ans</span><span class="o">=</span><span class="n">ans</span><span class="o">/</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> 
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">qpow</span><span class="p">(</span><span class="kt">int</span> <span class="n">base</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">){</span>
			<span class="n">ans</span><span class="o">=</span><span class="mi">1ll</span><span class="o">*</span><span class="n">ans</span><span class="o">*</span><span class="n">base</span><span class="o">%</span><span class="n">P</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">base</span><span class="o">=</span><span class="mi">1ll</span><span class="o">*</span><span class="n">base</span><span class="o">*</span><span class="n">base</span><span class="o">%</span><span class="n">P</span><span class="p">;</span>
		<span class="n">n</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">main</span><span class="p">(){</span>
	<span class="cm">/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/</span>

	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	
	<span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
		<span class="n">m</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">a</span><span class="o">&gt;&gt;</span><span class="n">P</span><span class="o">&gt;&gt;</span><span class="n">b</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">P</span><span class="o">&amp;&amp;</span><span class="n">P</span><span class="o">==</span><span class="n">b</span><span class="o">&amp;&amp;</span><span class="n">b</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">a</span><span class="o">%=</span><span class="n">P</span><span class="p">;</span><span class="n">b</span><span class="o">%=</span><span class="n">P</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">==</span><span class="mi">1</span><span class="o">||</span><span class="n">P</span><span class="o">==</span><span class="mi">1</span><span class="p">){</span>
			<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"0</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">B</span><span class="o">=</span><span class="n">ceil</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">euler</span><span class="p">(</span><span class="n">P</span><span class="p">)));</span>
		<span class="n">c</span><span class="o">=</span><span class="n">qpow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">B</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">q</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">powC</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">q</span><span class="o">&lt;</span><span class="n">B</span><span class="p">;</span><span class="n">q</span><span class="o">++</span><span class="p">){</span>
			<span class="k">auto</span> <span class="o">&amp;</span><span class="n">pl</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="n">powC</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="n">pl</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">){</span>
				<span class="n">pl</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
			<span class="p">}</span> 
			<span class="n">powC</span><span class="o">=</span><span class="mi">1ll</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">powC</span><span class="o">%</span><span class="n">P</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">2147483647</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">powA</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">r</span><span class="o">&lt;</span><span class="n">B</span><span class="p">;</span><span class="n">r</span><span class="o">++</span><span class="p">){</span>
			<span class="k">auto</span> <span class="o">&amp;</span><span class="n">pl</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mi">1ll</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">powA</span><span class="o">%</span><span class="n">P</span><span class="p">];</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">q</span><span class="o">:</span><span class="n">pl</span><span class="p">){</span>
				<span class="kt">int</span> <span class="n">x0</span><span class="o">=</span><span class="p">(</span><span class="mi">1ll</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">B</span><span class="o">-</span><span class="n">r</span><span class="p">)</span><span class="o">%</span><span class="n">P</span><span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">x0</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span> 
				<span class="k">if</span><span class="p">(</span><span class="n">qpow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x0</span><span class="p">)</span><span class="o">==</span><span class="n">b</span><span class="p">){</span>
					<span class="n">x</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x0</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">powA</span><span class="o">=</span><span class="mi">1ll</span><span class="o">*</span><span class="n">powA</span><span class="o">*</span><span class="n">a</span><span class="o">%</span><span class="n">P</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">2147483647</span><span class="p">){</span>
			<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
		<span class="p">}</span><span class="k">else</span><span class="p">{</span>
			<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"No Solution</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="n">cout</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
	
	<span class="cm">/*fclose(stdin);
	fclose(stdout);*/</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></div></code></pre></div></div>
</details>

# Wilson 定理



# Lucas 定理

## Lucas 定理

Lucas 定理用于求解大组合数取**质数模**。（对于模数不为质数的情况，请参考[exLucas](#exLucas 算法（exLucas 定理）)）。

Lucas 定理的内容很简单：

$$
\binom{n}{m}\equiv\binom{\lfloor\frac np\rfloor}{\lfloor\frac mp\rfloor}\binom{n\bmod p}{m\bmod p}\pmod p
$$

考虑如何证明。

### 证明

由二项式定理：

$$
(a+b)^p=\sum_{i=0}^p\binom pia^ib^{p-i}
$$

考虑 $\dbinom pi$ 在模 $p$ 意义下的取值。

因为：

$$
\dbinom pi=\dfrac{p!}{i!(p-i)!}
$$

那么如果化简之后，分子 $p!$ 中的 $p$ 项**没有**被约分掉，则有 $\dbinom pi\equiv p\cdot\dfrac{(p-1)!}{i!(p-i)!}\equiv0\pmod p$。

因为 $p$ 为质数，所以 $p$ 项能被约分掉当且仅当 $i!$ 中含有 $p$ 项或 $(p-i)!$ 中含有 $p$ 项。

即：$\dbinom pi\not\equiv0\pmod p$ 当且仅当 $i\equiv0\pmod p$ 或 $p-i\equiv 0\pmod p$。

在二项式定理中，$i$ 满足 $0\leq i\leq p$，所以 $\dbinom pi\not\equiv0$ 当且仅当 $i=0$ 或 $i=p$。

在这两种情况中，都可以计算得到 $\dbinom pi=1$，即 $\dbinom pi\equiv[i=0\lor i=p]$。

重新带回二项式定理，可得：
$$
\begin{aligned}
(a+b)^p&\equiv \dbinom{p}{0}a^0b^p+\dbinom ppa^pb^0\\
&\equiv a^p+b^p
\end{aligned}
\pmod p
$$

***

考虑一个二项式 $(1+x)^n\bmod p$。

$$
\begin{aligned}
(1+x)^n&\equiv (1+x)^{p\lfloor\frac np\rfloor+n\bmod p}\\
&\equiv(1+x)^{p\lfloor\frac np\rfloor}(1+x)^{n\bmod p}\\
&\equiv(1+x^p)^{\lfloor\frac np\rfloor}(1+x)^{n\bmod p}\\
\end{aligned}
\pmod p
$$

由二项式定理，$(1+x)^n$ 的 $x^m$ 项系数为 $\dbinom nm$。

而想要从 $(1+x^p)^{\lfloor\frac np\rfloor}(1+x)^{n\bmod p}$ 中得到 $x^m$，即从 $(1+x^p)^{\lfloor\frac np\rfloor}$ 中选取 $\lfloor\frac mp\rfloor$ 个 $x^p$，再从 $(1+x)^{n\bmod p}$ 中选取 $m\bmod p$ 个 $x$。

即：

$$
\dbinom nm\equiv\dbinom{\lfloor\frac np\rfloor}{\lfloor\frac mp\rfloor}\dbinom{n\bmod p}{m\bmod p}
\pmod p
$$

***

你可能有一个问题：这看起来明明应当是一个**等式**，但为什么是**同余**呢？

即，Lucas 定理应当表述为：
$$
\dbinom nm=\dbinom{\lfloor\frac np\rfloor}{\lfloor\frac mp\rfloor}\dbinom{n\bmod p}{m\bmod p}
$$
但是，你要知道，只有在模 $p$ 意义下才有 $(1+x)^{p\lfloor\frac np\rfloor}=(1+x^p)^{\lfloor\frac np\rfloor}$。

因此，只有在模 $p$ 意义下才有：

$$
\dbinom nm=\dbinom{\lfloor\frac np\rfloor}{\lfloor\frac mp\rfloor}\dbinom{n\bmod p}{m\bmod p}
$$

即：
$$
\dbinom nm\equiv\dbinom{\lfloor\frac np\rfloor}{\lfloor\frac mp\rfloor}\dbinom{n\bmod p}{m\bmod p}\pmod p
$$

### 应用

当 $n$ 比较大而无法使用其他方法（例如预处理 $1\sim n$ 的阶乘再利用乘法逆元）直接求解组合数时，可以使用 Lucas 定理。

Lucas 定理只需要递归使用即可，即递归计算 $\dbinom{\lfloor\frac np\rfloor}{\lfloor\frac mp\rfloor}$，递归终点即 $\dbinom{0}{0}$。

其时间复杂度为：$\mathcal O\left(f(p)\log m\right)$。

其中，$f(p)$ 表示单次计算 $\dbinom{n\bmod p}{m\bmod p}$ 的复杂度，因写法而异。

可以使用乘法逆元，则时间复杂度为 $\mathcal O(\log p\log m)$。

也可以 $\mathcal O(p\log p)$ 递推，时间复杂度为 $\mathcal O(p\log p\log m)$。

推荐使用乘法逆元。

> [例题链接](https://www.luogu.com.cn/problem/P3807)

很简单，注意是 $\dbinom{n+m}{n}$ 即可。

<details class="success">
    <summary>参考代码</summary>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><div class="table-responsive"><table class="rouge-table table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="c1">//#include&lt;bits/stdc++.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstring&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;ctime&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;deque&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;list&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span><span class="o">=</span><span class="mf">1e5</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">ksm</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">t</span><span class="o">=</span><span class="n">ksm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
	<span class="n">t</span><span class="o">=</span><span class="mi">1ll</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">t</span><span class="o">%</span><span class="n">p</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span><span class="n">t</span><span class="o">=</span><span class="mi">1ll</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">a</span><span class="o">%</span><span class="n">p</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">C</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">ans</span><span class="p">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1ll</span><span class="o">*</span><span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="o">*</span><span class="n">ksm</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">p</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="p">;</span>
	<span class="p">}</span><span class="k">return</span> <span class="n">ans</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">Lucas</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">m</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1ll</span><span class="o">*</span><span class="n">Lucas</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">p</span><span class="p">,</span><span class="n">m</span><span class="o">/</span><span class="n">p</span><span class="p">,</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">p</span><span class="p">,</span><span class="n">m</span><span class="o">%</span><span class="n">p</span><span class="p">,</span><span class="n">p</span><span class="p">))</span><span class="o">%</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="cm">/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/</span>

	<span class="kt">int</span> <span class="n">T</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">p</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">T</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="n">T</span><span class="o">--</span><span class="p">){</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">Lucas</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">));</span>
	<span class="p">}</span>
	
	<span class="cm">/*fclose(stdin);
	fclose(stdout);*/</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></div></code></pre></div></div>
</details>

## exLucas 算法（exLucas 定理）

<details class="note" open>
    <summary>前置知识</summary>
    <p>
        <ul>
            <li><a href="#exgcd 求乘法逆元">exgcd 求乘法逆元</a></li>
            <li><a href="#CRT">CRT</a></li>
            <li><a href="#Wilson 定理">Wilson 定理</a></li>
        </ul>
    </p>
</details>

exLucas 算法可以求 $\dbinom{n}{m}\bmod P$，$P$ **不一定为质数**。（但是，exLucas 实际上和 Lucas 没有多大关系……）

由唯一分解定理，可以对 $P$ 进行质因数分解：

$$
P=p_1^{c_1}p_2^{c_2}p_3^{c_3}\cdots p_n^{c^n}
$$

### CRT 求解

我们如果能够求出 $a_1,a_2,\cdots,a_n$ 使得：
$$
\begin{cases}
\dbinom nm&\equiv a_1\pmod{p_1^{c_1}}\\
\dbinom nm&\equiv a_2\pmod{p_1^{c_2}}\\
&\cdots\\
\dbinom nm&\equiv a_n\pmod{p_n^{c_n}}\\
\end{cases}
$$

那么我们就可以通过 **CRT** 求解出 $\dbinom nm\bmod P$。因为在 CRT 中，恰好也有 $P=p_1^{c_1}p_2^{c_2}\cdots p_n^{c_n}$。

### 求解模质数幂下余数

展开定义式：

$$
\dbinom nm=\frac{n!}{m!(n-m)!}
$$

因此：

$$
\dbinom nm\equiv\frac{n!}{m!(n-m)!}\pmod{p_i^{c_i}}
$$

因为 $p_i^{c_i},m!,(n-m)!$ 不一定互质，因此**乘法逆元不一定存在**。

考虑先**提出**分子和分母中所有的 $p_i$ 次幂，随后便可以使用逆元求解。

记 $x$ 的质因数分解中**质数** $p$ 的幂次为 $\nu_p(x)$，剩余积为 $(x)_p$，即：

$$
x=p^{\nu_p(x)}\cdot(x)_p
$$

则有：

$$
\frac{n!}{m!(n-m)!}\equiv\frac{(n!)_{p_i}}{(m!)_{p_i}((n-m)!)_{p_i}}\cdot p_i^{\nu_{p_i}(n!)-\nu_{p_i}(m!)-\nu_{p_i}((n-m)!)}\pmod{p_i^{c_i}}
$$

那么，现在只需要考虑对于 $x,p$，如何**高效地**求出 $\nu_{p}(x!)\bmod p_i^{c_i},(x!)_p\bmod p_i^{c_i}$。

***

考虑：

$$
x!=1\times2\times\cdots\times p\times\cdots\times2p\times\cdots\times\left\lfloor\dfrac{x}{p}\right\rfloor p\times\cdots\times x
$$

容易发现，在 $p,2p,3p,\cdots,\left\lfloor\dfrac xp \right\rfloor p$ 中 $p$ 的个数为 $\left\lfloor\dfrac xp\right\rfloor+\nu_p\left(\left\lfloor\dfrac xp \right\rfloor!\right)$。其中 $\nu_p\left(\left\lfloor\dfrac xp \right\rfloor!\right)$ 是 $1,2,3,\cdots,\left\lfloor\dfrac xp\right\rfloor$ 中的 $p$ 的个数。

$p$ 为**质数**，所以在 $1,2,3,\cdots,p-1,p+1,\cdots$ 中不会含有 $p$。

将递推式展开：

$$
\begin{aligned}
\nu_p\left(x!\right)&=\left\lfloor\dfrac xp\right\rfloor+\nu_p\left(\left\lfloor\dfrac xp \right\rfloor!\right)\\
&=\left\lfloor\dfrac xp\right\rfloor+\left\lfloor\dfrac x{p^2}\right\rfloor+\nu_p\left(\left\lfloor\dfrac xp^2 \right\rfloor!\right)\\
&=\left\lfloor\dfrac xp\right\rfloor+\left\lfloor\dfrac x{p^2}\right\rfloor+\left\lfloor\dfrac x{p^3}\right\rfloor+\cdots
\end{aligned}
$$

因此可以 $\mathcal O(\log_p x)$ 计算 $\nu_p(x!)$：

```cpp
int v(ll n,ll p){
	int ans=0;
	do{
		n/=p;
		ans+=n;
	}while(n);
	return ans;//这里取不取模其实都无所谓,因为幂次不会太多,想取也可以.
}
```

***

现在考虑如何计算 $(x!)_p\bmod p^c$；显然不能利用定义式 $(x!)_p=\dfrac{x!}{\nu_p(x!)}$，而需要其他方法（因为无法得知 $x!$）。

不难进行递推：
$$
\begin{aligned}
(x!)_p&\equiv\prod_{i=1}^n(i)_p\\
&\equiv\left(\prod_{1\leq i\leq x,i\perp p}(i)_p\right)\left(\prod_{i=1}^{\left\lfloor\frac xp\right\rfloor}(p\cdot i)_p\right)\\
&\equiv\left(\prod_{1\leq i\leq x,i\perp p}(i)_p\right)\left(\left\lfloor\frac xp\right\rfloor!\right)_p\\
&\equiv\left(\prod_{1\leq i\leq p^c,i\perp p}i\right)^{\left\lfloor\frac{x}{p^c}\right\rfloor}\left(\prod_{1\leq i\leq x\bmod p^c,i\perp p}i\right)\left(\left\lfloor\frac xp\right\rfloor!\right)_p\\
\end{aligned}
$$

由 Wilson 定理的推论（$m=2,4,p^c,2p^c$ 时 $k\equiv-1$，否则为 $1$）：

$$
\prod_{1\leq k\leq m,k\perp m}k\equiv\pm1\pmod m
$$

因此：

$$
\begin{aligned}
(x!)_p&\equiv(\pm1)^{\left\lfloor\frac{x}{p^c}\right\rfloor}\left(\prod_{1\leq i\leq x\bmod p^c,i\perp p}i\right)\left(\left\lfloor\frac xp\right\rfloor!\right)_p
\end{aligned}
$$

可以发现，每次计算 $(x!)_p$ 时，$p^c$ 是固定的，因此可以预处理：

$$
f_j\equiv\prod_{1\leq i\leq j,i\perp p}i\pmod p^c
$$

因此，得到最终推导式：

$$
\begin{aligned}
(x!)_p&\equiv(\pm1)^{\left\lfloor\frac{x}{p^c}\right\rfloor}f_{x\bmod p^c}\left(\left\lfloor\frac xp\right\rfloor!\right)_p
\end{aligned}
$$

可以递归或迭代处理，时间复杂度 $\mathcal O(p^c+\log n x)$。

```cpp
int Wilson(int n,int p,int pc){
	int ans=1;
	vector<int>f(pc)
	f[0]=1;
	for(int i=1;i<pc;i++){
		f[i]=i%p?f[i-1]*i%pc:f[i-1];
	}
	bool flag=p!=2||pc<=4;
	while(n>1){
		if((n/pc)&flag){
			ans=pc-ans;
		}
		ans=ans*f[n%pc]%pc;
		n/=p;
	}
	return ans;
}
```

> [例题链接](https://www.luogu.com.cn/problem/P4720)

<details class="success">
    <summary>参考代码</summary>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><div class="table-responsive"><table class="rouge-table table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
</pre></td><td class="rouge-code"><pre><span class="c1">//#include&lt;bits/stdc++.h&gt;</span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstring&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;ctime&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;deque&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;list&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
<span class="cp">#define ll __int128
#define int __int128
</span><span class="k">constexpr</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">PMAX</span><span class="o">=</span><span class="mf">1e6</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">exgcd</span><span class="p">(</span><span class="n">ll</span> <span class="n">a</span><span class="p">,</span><span class="n">ll</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="n">ll</span> <span class="n">b</span><span class="p">,</span><span class="n">ll</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">){</span>
		<span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ll</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">exgcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">tmp</span><span class="p">,</span><span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
	<span class="n">y</span><span class="o">=</span><span class="n">tmp</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">ll</span> <span class="nf">inverse</span><span class="p">(</span><span class="n">ll</span> <span class="n">a</span><span class="p">,</span><span class="n">ll</span> <span class="n">p</span><span class="p">){</span>
	<span class="n">ll</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
	<span class="n">exgcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
	<span class="n">x</span><span class="o">%=</span><span class="n">p</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
		<span class="n">x</span><span class="o">+=</span><span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">qpow</span><span class="p">(</span><span class="kt">int</span> <span class="n">base</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">){</span>
			<span class="n">ans</span><span class="o">=</span><span class="mi">1ll</span><span class="o">*</span><span class="n">ans</span><span class="o">*</span><span class="n">base</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">base</span><span class="o">=</span><span class="mi">1ll</span><span class="o">*</span><span class="n">base</span><span class="o">*</span><span class="n">base</span><span class="p">;</span>
		<span class="n">n</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">CRT</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">a</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">p</span><span class="p">){</span>
	<span class="n">ll</span> <span class="n">L</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">:</span><span class="n">p</span><span class="p">){</span>
		<span class="n">L</span><span class="o">*=</span><span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ll</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">ll</span> <span class="n">q</span><span class="o">=</span><span class="n">L</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">x</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1ll</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">q</span><span class="o">%</span><span class="n">L</span><span class="o">*</span><span class="n">inverse</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">%</span><span class="n">L</span><span class="p">)</span><span class="o">%</span><span class="n">L</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
		<span class="n">x</span><span class="o">+=</span><span class="n">L</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">v</span><span class="p">(</span><span class="n">ll</span> <span class="n">n</span><span class="p">,</span><span class="n">ll</span> <span class="n">p</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span><span class="p">{</span>
		<span class="n">n</span><span class="o">/=</span><span class="n">p</span><span class="p">;</span>
		<span class="n">ans</span><span class="o">+=</span><span class="n">n</span><span class="p">;</span>
	<span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">Wilson</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span><span class="kt">int</span> <span class="n">pc</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">f</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">pc</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="o">%</span><span class="n">p</span><span class="o">?</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">i</span><span class="o">%</span><span class="n">pc</span><span class="o">:</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="kt">bool</span> <span class="n">flag</span><span class="o">=</span><span class="n">p</span><span class="o">!=</span><span class="mi">2</span><span class="o">||</span><span class="n">pc</span><span class="o">&lt;=</span><span class="mi">4</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">){</span>
		<span class="k">if</span><span class="p">((</span><span class="n">n</span><span class="o">/</span><span class="n">pc</span><span class="p">)</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">){</span>
			<span class="n">ans</span><span class="o">=</span><span class="n">pc</span><span class="o">-</span><span class="n">ans</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ans</span><span class="o">=</span><span class="n">ans</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="o">%</span><span class="n">pc</span><span class="p">]</span><span class="o">%</span><span class="n">pc</span><span class="p">;</span>
		<span class="n">n</span><span class="o">/=</span><span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">breakDown</span><span class="p">(</span><span class="kt">int</span> <span class="n">P</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="n">p</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="n">pc</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">pp</span><span class="o">=</span><span class="n">P</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">pp</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">pp</span><span class="o">%</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
			<span class="n">p</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="n">pc</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">while</span><span class="p">(</span><span class="n">pp</span><span class="o">%</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
				<span class="n">pc</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">*=</span><span class="n">i</span><span class="p">;</span>
				<span class="n">pp</span><span class="o">/=</span><span class="n">i</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pp</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">){</span>
		<span class="n">p</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pp</span><span class="p">);</span>
		<span class="n">pc</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span> 
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">exLucas</span><span class="p">(</span><span class="n">ll</span> <span class="n">n</span><span class="p">,</span><span class="n">ll</span> <span class="n">m</span><span class="p">,</span><span class="n">ll</span> <span class="n">P</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&lt;</span><span class="n">m</span><span class="p">){</span> 
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">p</span><span class="p">,</span><span class="n">pc</span><span class="p">;</span>
	<span class="n">breakDown</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">pc</span><span class="p">);</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">a</span><span class="p">(</span><span class="n">pc</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">nWilson</span><span class="o">=</span><span class="n">Wilson</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">pc</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="kt">int</span> <span class="n">mWilson</span><span class="o">=</span><span class="n">Wilson</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">pc</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="kt">int</span> <span class="n">nmWilson</span><span class="o">=</span><span class="n">Wilson</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">pc</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">nWilson</span><span class="o">*</span><span class="n">inverse</span><span class="p">(</span><span class="n">mWilson</span><span class="o">*</span><span class="n">nmWilson</span><span class="o">%</span><span class="n">pc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">pc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">qpow</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-</span><span class="n">v</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-</span><span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">CRT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">pc</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">main</span><span class="p">(){</span>
	<span class="cm">/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/</span>

	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">P</span><span class="p">;</span>
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="n">m</span><span class="o">&gt;&gt;</span><span class="n">P</span><span class="p">;</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">exLucas</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">P</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
	
	<span class="n">cout</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
	
	<span class="cm">/*fclose(stdin);
	fclose(stdout);*/</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
1000000000000000000 500000000000000000 998243

0
*/</span>
</pre></td></tr></tbody></table></div></code></pre></div></div>
</details>

# 群论

群论是近代数学的基础之一。

> 群即对称，对称即群。

“群”是一种**代数结构**，群 $(G,\circ)$ 由一个集合 $G$ 和一个二元运算符 $\circ$ 组成。

群 $(G,\circ)$ 需要满足以下**性质**：

* 封闭性。即对于 $\forall a,b\in G$，有 $a\circ b\in G$。

* 结合律。即对于二元运算 $\circ$ 满足 $a\circ(b\circ c)=(a\circ b)\circ c$。

* 存在单位元。即存在 $e\in G$ 满足对于 $\forall a\in G$ 有 $e\circ a=a\circ e=a$。

  例如在 $\circ$ 为乘法的情况下，单位元 $e$ 为 $1$。

* 存在逆元。即对于 $\forall a\in G$，存在 $x\in G$ 满足 $a\circ x=x\circ a=e$。

  记 $x$ 为 $a^{-1}$。

同时，记：

$$
\underbrace{a\circ a\circ a\circ \cdots\circ a}_{x\text{ 个 }a}=a^x
$$

有时为了**强调单位元**，也会将群 $(G,\circ)$ 记作群 $(G,\circ,e)$。

例如这两个群：

* 群 $(\Z,+,0)$。

  显然满足上文所述性质。

  **无限群**与整数集加法群同构。

* 群 $(\lbrace0,1,2,\cdots,p-1\rbrace,+_{\bmod p})$，其中 $+_{\bmod p}$ 表示模 $p$ 意义下的加法。

  显然也满足上文所述性质。

  **有限群**与模意义下的整数集加法群同构。

***需要注意的是，群不一定需要满足交换律***。

## 群的性质

已知 $(G,\circ,e)$ 是一个群。

### 单位元唯一

假设存在两个不同的单位元 $e_1,e_2\in G$。

那么有 $e_1=e_1\circ e_2=e_2$，则 $e_1=e_2$。

故，单位元唯一。

### 消去律

* 左消去律：$a\circ b=a\circ c\Rightarrow b=c$。
* 右消去律：$a\circ b=c\circ b\Rightarrow a=c$。

### 逆元唯一

假设 $a$ 存在两个不同的逆元 $a_1,a_2$。

则有 $a\circ a_1=a\circ a_2=e$。

由消去律有 $a_1=a_2$。

故，逆元唯一。

### 逆元的拆解

对于 $\forall a,b\in G$，有 $(a\circ b)^{-1}=b^{-1}\circ a^{-1}$。

由群的性质，可以得到：

$$
(a\circ b)^{-1}\circ (a\circ b)=e\\
b^{-1}\circ a^{-1}\circ (a\circ b)=b^{-1}\circ(a^{-1}\circ a)\circ b=b^{-1}\circ e\circ b=e
$$



因此，有 $(a\circ b)^{-1}=b^{-1}\circ a^{-1}$。

## 群的有关概念

已知 $(G,\circ,e)$ 是一个群。

### 有限群

当 $G$ 为有限集时。

**有限群**与模意义下的整数集加法群同构。

#### 群的阶

群 $(G,\circ,e)$ 的阶即 $\vert G\vert$。

### 无限群

当 $G$ 为无限集时。

**无限群**与整数集加法群同构。

### 阿贝尔群

若二元运算 $\circ$ 满足交换律，即满足 $a\circ b=b\circ a$，则称群 $(G,\circ,e)$ 为**阿贝尔群**、**可交换群**或**加法群**。

### 子群

设集合 $H\in G$ 且 $\vert H\vert>0$。

如果满足 $(H,\circ,e)$ 为一个群，则称群 $(H,\circ,e)$ 是群 $(G,\circ,e)$ 的子群，记作 $H\leq G$。

#### 平凡子群

对于任意群 $(G,\circ,e)$，总有平凡子群 $(G,\circ,e)$ 和 $(\lbrace e\rbrace,\circ,e)$。

# 莫比乌斯反演

