---
layout: post
title: "题解：Physical Education Lessons"
subtitle: "CF915E"
date: 2025-8-16
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 题解
  - 提高+/省选−
  - ODT 珂朵莉树
words:
  - "CF915E 题解：Physical Education Lessons"
---

> [题目传送门](https://www.luogu.com.cn/problem/CF915E)

# 题意分析

操作即区间赋值为 $0$ 或 $1$，求 $1$ 的个数。

显然可以 ODT 维护。

注意不要滥用 `perform` 操作，而应当维护全局标记。

因为不存在 `perform` 操作，故有时间复杂度：$\mathcal O(q\log n)$。

# AC 代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
#include<set>
using namespace std;
constexpr const int N=1e5;
int n,ans;
struct ODT{
	struct node{
		int l,r;
		mutable int value;
	};
	friend bool operator <(node a,node b){
		return a.l<b.l;
	}
	set<node>t;
	void build(int l,int r){
		t.clear();
		t.insert({l,r+1});
	}
	auto split(int x){
		auto p=t.lower_bound({x});
		if(p!=t.end()&&p->l==x){
			return p;
		}
		p=prev(p);
		int l=p->l,r=p->r,value=p->value;
		t.erase(p);
		t.insert({l,x-1,value});
		return t.insert({x,r,value}).first;
	}
	void assign(int l,int r,int value){
		auto pr=split(r+1);
		auto pl=split(l);
		for(auto i=pl;i!=pr;i=next(i)){
			if(value&&!i->value){
				ans+=i->r - i->l + 1;
			}else if(i->value && !value){
				ans-=i->r - i->l + 1;
			}
		}
		t.erase(pl,pr);
		t.insert({l,r,value});
	}
}t;
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	int q;
	cin>>n>>q;
	t.build(1,n);
	t.assign(1,n,1);
	ans=n;
	while(q--){
		int l,r,k;
		cin>>l>>r>>k;
		t.assign(l,r,k-1);
		cout<<ans<<'\n';
	}
	
	cout.flush();
	 
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

