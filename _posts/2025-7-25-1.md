---
layout: post
title: "NOIP 二十年 DP 训练总结"
subtitle: "2005 至 2024 NOIP 动态规划真题"
date: 2025-7-25
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 题解
  - 普及−
  - 普及/提高−
  - 普及+/提高
  - 提高+/省选−
  - 省选/NOI−
  - DP
  - 数学
  - 贪心
  - DDP
  - 未完
words:
  - "P1048 题解：[NOIP 2005 普及组] 采药"
  - 01 背包01背包
  - "P1060 题解：[NOIP 2006 普及组] 开心的金明"
  - 完全背包最大子段和
  - "P1077 题解：[NOIP 2012 普及组] 摆花NOIP2012"
  - "P1057 题解：[NOIP 2008 普及组] 传球游戏NOIP2008"
  - NOIP2005NOIP2006NOIP2006NOIP2007NOIP2008NOIP2009NOIP2010NOIP2011NOIP2012NOIP2013NOIP2014NOIP2015NOIP2016NOIP2017NOIP2018NOIP2019NOIP2020NOIP2021NOIP2022NOIP2023NOIP2024
  - "P1095 题解：[NOIP 2007 普及组] 守望者的逃离"
  - "P1970 题解：[NOIP 2013 提高组] 花匠"
  - "P1351 题解：[NOIP 2014 提高组] 联合权值"
  - "P2679 题解：[NOIP 2015 提高组] 子串"
  - "P1005 题解：[NOIP 2007 提高组] 矩阵取数游戏"
  - "P5020 题解：[NOIP 2018 提高组] 货币系统"
  - "P1982 题解：[NOIP 2013 普及组] 小朋友的数字"
  - "P1052 题解：[NOIP 2005 提高组] 过河"
  - "P1063 题解：[NOIP 2006 提高组] 能量项链"
  - "P1850 题解：[NOIP 2016 提高组] 换教室"
  - "P2831 题解：[NOIP 2016 提高组] 愤怒的小鸟"
  - "P3957 题解：[NOIP 2017 普及组] 跳房子"
  - "P3953 题解：[NOIP 2017 提高组] 逛公园"
  - "P3959 题解：[NOIP 2017 提高组] 宝藏"
  - "P5017 题解：[NOIP 2018 普及组] 摆渡车"
  - "P5023 题解：[NOIP 2018 提高组] 填数游戏"
  - "P7961 题解：[NOIP2021] 数列"
  - "P8865 题解：[NOIP2022] 种花"
  - "P2258 题解：[NOIP 2014 普及组] 子矩阵"
  - "P1941 题解：[NOIP 2014 提高组] 飞扬的小鸟"
  - "P5024 题解：[NOIP 2018 提高组] 保卫王国"
---

> 持续更新中，对于较为简单的题目，会直接给出题解。对于较为复杂的题目，会给出**核心摘要**及**详细题解的链接**。
>
> 题目主要来源于[此处](https://www.luogu.com.cn/problem/list?type=luogu&page=1&tag=3,129,139,141,144,152,323,435,443,444,464|82,83|22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,58,59,60)，以及一些没有 DP 标签但自认为与 DP 有较深的关系的题目。

# NOIP2005

> [[NOIP 2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)

经典 01 背包问题。

<details class="success">
    <summary>参考代码</summary>


```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
int n,m,w[1001],c[1001],f[1001][1001];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>w[i]>>c[i];
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			f[i][j]=f[i-1][j];
			if(j>=w[i])f[i][j]=max(f[i][j],f[i-1][j-w[i]]+c[i]);
		}
	}
	cout<<f[m][n]<<endl;
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

</details>

> [[NOIP 2005 提高组] 过河](https://www.luogu.com.cn/problem/P1052)

首先不难设计朴素 DP：设 $\textit{dp}_{i}$ 表示跳到坐标 $i$ 时的最小石子数量。

记 $\textit{flag}_{i}$ 表示坐标 $i$ 是否有石子，有：

$$
\textit{dp}_i=\min_{j=i-t}^{i-s}\textit{dp}_j+\textit{flag}_i
$$

注意到 $L\leq10^9$，会 MLE。因此考虑优化。发现 $1\leq s,t\leq10$，也许有一些性质可以利用。

令两个石子之间的距离为 $x$。

则若 $x>t(t-1)$，则 $x\iff t(t-1)$。由此可以 DP。

<details class="note">
    <summary>证明</summary>
    <p>
        不妨设步数仅有两种：$p,p+1$。
    </p>
    <p>
        设 $p$ 走了 $x$ 步，$p+1$ 走了 $y$ 步。
    </p>
    <p>
        设最终走到的点为 $z$，则有：
    </p>
    <p>
        $$
        px+(p+1)y=n
        $$
    </p>
    <p>
        因为 $\gcd(p,p+1)=1$，由裴蜀定理，上述方程一定有<b>整数解</b>。
    </p>
    <p>
        当 $0\leq x\leq p$ 时，有：
    </p>
    <p>
        $$
        y=\dfrac{m-px}{p+1}\geq\dfrac{m-p^2}{p+1}\geq\dfrac{p(p+1)-px-1}{p+1}\geq0
        $$
    </p>
    <p>
        因此，当 $m\geq p(p+1)$ 时，$p(p+1)$ 之后的点一定能走到。
    </p>
</details>

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
int l,s,t,m,f[10001],a[10001],flag[10001]; 
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	scanf("%d",&l); 
    scanf("%d%d%d",&s,&t,&m); 
    for(int i=1;i<=m;i++)scanf("%d",a+i);
    if(s==t){ 
        int cnt=0;
        for(int i=1;i<=m;i++)cnt+=((a[i]%s)==0); 
        printf("%d\n",cnt);
		return 0; 
    }sort(a+1,a+m+1);
	int pl=min(l-a[m],100);
	for(int i=m;i>=1;i--)a[i]=min(a[i]-a[i-1],90);
	l=0;
	for(int i=1;i<=m;i++){
		l+=a[i];
		flag[l]=true;
	}l+=pl;
	for(int i=1;i<=l+t;i++){
		f[i]=2147483646;
		for(int j=s;j<=t;j++){
			if(i>=j)f[i]=min(f[i],f[i-j]+flag[i]);
		}
	}
	int Min=2147483647;
	for(int i=l;i<=l+t;i++)Min=min(Min,f[i]); 
	printf("%d",Min); 
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>



# NOIP2006


> [[NOIP 2006 普及组] 开心的金明](https://www.luogu.com.cn/problem/P1060)

经典完全背包问题。

<details class="success">
    <summary>参考代码</summary>


```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
//v:价格,p:单个乘积,f:Dp数组 
int n,m,v[25],p[25],f[25][30000];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>v[i]>>p[i];
		p[i]*=v[i];
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			f[i][j]=f[i-1][j];
			if(j>v[i])f[i][j]=max(f[i][j],f[i-1][j-v[i]]+p[i]);
		}
	} 
	cout<<f[m][n]<<endl;
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

</details>

> [[NOIP 2006 提高组] 能量项链](https://www.luogu.com.cn/problem/P1063)

记 $L(i),R(i)$ 分别表示 $i$ 的前驱/后继。

记 $\textit{dp}_{l,r}$ 表示珠子 $l,l+1,\cdots,r$ 按照某种顺序合并的最大能量，则有：

$$
\textit{dp}_{l,r}=\max_{i=l}^r\left(\textit{dp}_{l,i}+a_la_{R(i)}a_{R(r)}+\textit{dp}_{i,r}\right)
$$

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
int n,a[101],s[101][101];
int L(int x){
	if(x==1)return n;
	return x-1;
}
int R(int x){
	if(x==n)return 1;
	return x+1;
}//[l,r]最大能量 
int f(int l,int r){
	if(s[l][r])return s[l][r];
	int cnt=0;
	for(int i=l;i!=r;i=R(i)){
		cnt=max(cnt, f(l,i) + f(R(i),r) + a[l] * a[R(i)] * a[R(r)] );
	}return s[l][r]=cnt;
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",a+i);
	int ans=0;
	for(int i=1;i<=n;i++)ans=max(ans,f(i,L(i)));//环 
	printf("%d\n",ans);
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

# NOIP2007

> [[NOIP 2007 普及组] 守望者的逃离](https://www.luogu.com.cn/problem/P1095)

贪心即可。

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
long long m,s,t,run,fly;
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/

	cin>>m>>s>>t;
	for(int i=1;i<=t;i++){
		run+=17;//跑步17m/s
		if(m>=10){
			m-=10;
			fly+=60;
		}else m+=4;
		run=max(run,fly);
		if(run>=s){
			cout<<"Yes"<<endl<<i<<endl;
			return 0;
		}
	}cout<<"No"<<endl<<run<<endl;
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>


> [[NOIP 2007 提高组] 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005)

首先需要理解题意：

* 不同行之间是独立的。
* 设计一种方式，使得行内得分最大。
* 求所有行的得分之和。

考虑单独一行如何做。设 $\textit{dp}_{l,r}$ 表示取数取走 $a_l,a_{l+1},\cdots,a_r$ 时的最大得分。

则有：

$$
\textit{dp}_{l,r}=2\max\left(\textit{dp}_{l+1,r}+a_l,\textit{dp}_{l,r-1}+a_r\right)
$$

考虑第 $i$ 次取 $x$，$x$ 的贡献是 $2^ix$，即上式。因为每次乘 $2$，里面的数便相当于乘上 $2^{i'}$。

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef __int128 lll;
constexpr const int N=80,M=80;
int n,m,a[N+1][M+1];
lll f(int i,int l,int r){
	static lll mem[N+1][N+1][N+1];
	if(l<1||m<l||r<1||m<r||r<l){
		return 0;
	}
	lll &ans=mem[i][l][r];
	if(ans){
		return ans;
	}
	return ans=2*max(f(i,l+1,r)+a[i][l],f(i,l,r-1)+a[i][r]);
}
template<typename T>
void Write(T x){
	static char s[101];
	int top=0;
	do{
		s[++top]=x%10^'0';
		x/=10;
	}while(x);
	while(top){
		cout<<s[top--];
	}
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	lll ans=0;
	for(int i=1;i<=n;i++){
		ans+=f(i,1,m);
	}
	Write(ans);
	cout<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>



# NOIP2008

> [[NOIP 2008 普及组] 传球游戏](https://www.luogu.com.cn/problem/P1057)

设计状态 $f_{i,j}$ 表示传球 $i$ 次，传球到 $j$ 的方案数，答案为 $f_{m,1}$。

不考虑边界，则有：

$$
f_{i,j}=f_{i-1,j-1}+f_{i-1,j+1}
$$

即从 $j-1,j+1$ 传球到 $j$。 

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef long long ll;
ll n,m,f[31][31];
ll F(int i,int j){
	if(j<1)return f[i][n];
	if(j>n)return f[i][1];
	return f[i][j];
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	scanf("%lld %lld",&n,&m);
	f[0][1]=1; 
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			f[i][j]=F(i-1,j-1)+F(i-1,j+1);
		}
	}printf("%lld\n",f[m][1]);
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

</details>

# NOIP2009

# NOIP2010

# NOIP2011

# NOIP2012

> [[NOIP 2012 普及组] 摆花](https://www.luogu.com.cn/problem/P1077)

一个很容易想到的 DP 状态是设 $\textit{dp}_{i,j}$ 表示前 $i$ 种花摆了 $j$ 盆的合法方案数。

则有：

$$
\begin{aligned}
\textit{dp}_{i,j}&=\sum_{k=0}^{\min(a_i,k)}\textit{dp}_{i-1,j-k}\\
\textit{dp}_{0,0}&=1
\end{aligned}
$$

<details class="success">
    <summary>参考代码</summary>


```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=100,M=100,P=1e6+7;
int n,m,a[N+1],dp[N+1][M+1];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/

	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=m;j++){
			for(int k=0;k<=a[i]&&k<=j;k++){
				dp[i][j]=(dp[i][j]+dp[i-1][j-k])%P;
			}
		}
	}
	cout<<dp[n][m]<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

</details>

# NOIP2013

> [[NOIP 2013 提高组] 花匠](https://www.luogu.com.cn/problem/P1970)

显然，最后剩下的花的高度 $g_1,g_2,g_3,\cdots,g_m$ 需要满足下列性质任意一条：

* $g_1<g_2>g_3<g_4>\cdots$
* $g_1>g_2<g_3>g_4<\cdots$

那么，可以据此设计 $\textit{dp}_{i,j},j\in\set{0,1}$ 表示留下 $g_{i'}=h_i$ 时最多留下的花的数量，且满足：

* $j=0$：$g_{i'-1}>g_{i'}$。
* $j=1$：$g_{i'-1}<g_{i'}$。

则可以写出转移方程：

$$
\begin{aligned}
\textit{dp}_{i,0}&=\max_{h_j>h_i\land j<i}\textit{dp}_{j,1}+1\\
\textit{dp}_{i,1}&=\max_{h_j<h_i\land j<i}\textit{dp}_{j,0}+1\\
\end{aligned}
$$

只需要使用线段树优化 DP，或者树状数组优化 DP 即可。

<details class="success">
    <summary>参考代码</summary>


```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
//typedef (*fp)(int,int);
constexpr const int N=2e6,H=1e9;
int n,h[N+1];
int dp[N+1][2];
//前缀最大值 
struct bitPre{
	int t[N+3+1];
	int lowbit(int x){
		return x&-x;
	}
	void set(int x,int k){
		x+=2;
		while(x<=N+3){
			k=max(t[x],k);
			t[x]=k;
			x+=lowbit(x);
		}
	}
	int query(int x){
		x+=2;
		int ans=0;
		while(x){
			ans=max(ans,t[x]);
			x-=lowbit(x);
		} 
		return ans;
	}
}t0;
struct bitSuf{
	int t[N+3+1];
	int lowbit(int x){
		return x&-x;
	}
	void set(int x,int k){
		x+=2;
		while(x){
			k=max(t[x],k);
			t[x]=k;
			x-=lowbit(x);
		} 
	}
	int query(int x){
		x+=2;
		int ans=0;
		while(x<=N+3){
			ans=max(ans,t[x]);
			x+=lowbit(x);
		}
		return ans;
	}
}t1;
void pre(){
	static int tmp[N+1];
	for(int i=1;i<=n;i++){
		tmp[i]=h[i];
	}
	sort(tmp+1,tmp+n+1);
	int len=unique(tmp+1,tmp+n+1)-tmp-1;
	for(int i=1;i<=n;i++){
		h[i]=lower_bound(tmp+1,tmp+len+1,h[i])-tmp;
	}
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>h[i];
	}
	pre();
	for(int i=1;i<=n;i++){
		dp[i][0]=t1.query(h[i]+1)+1;
		dp[i][1]=t0.query(h[i]-1)+1;
		t0.set(h[i],dp[i][0]);
		t1.set(h[i],dp[i][1]);
	}
	int ans=-1;
	for(int i=1;i<=n;i++){
		ans=max({ans,dp[i][0],dp[i][1]});
	}
	cout<<ans<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

</details>

> [[NOIP 2013 普及组] 小朋友的数字](https://www.luogu.com.cn/problem/P1982)

最大子段和问题。

记数字为 $\textit{num}_i$，特征值为 $a_i$，分数为 $f_i$。

则有：

$$
\begin{aligned}
a_i&=\max_{1\leq l\leq r\leq i}\sum_{j=l}^r\textit{num}_j\\
&=\max\left(a_{i-1}+\textit{num}_i,a_{i-1}\right)\\
f_i&=
\begin{cases}
a_1&i=1\\
\max\left(f_{i-1},f_{i-1}+\max\limits_{j=1}^{i-1}a_j\right)&i>1
\end{cases}
\end{aligned}
$$

答案为 $\max\limits_{i=1}^nf_i\bmod p$。$\mathcal O(n)$ 计算。

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef __int128 lll;
typedef long long ll;
constexpr const int N=1e6;
int n,P;
ll a[N+1];
lll f[N+1];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>P;
	f[0]=-(1ll<<62);
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i]=max(a[i-1]+a[i],a[i]);
		f[i]=max(f[i-1],(lll)a[i]);
	}
	lll pl=f[1]+a[1],ans=f[1];
	for(int i=2;i<=n;i++){
		ans=max(ans,pl);
		pl=max(pl,pl+f[i]);
	}
	cout<<(int)(ans%P)<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

# NOIP2014

> [[NOIP 2014 提高组] 联合权值](https://www.luogu.com.cn/problem/P1351)

$n$ 个点却是 $n-1$ 条边，显然是一棵树，令根节点为 $1$。记 $f_x$ 表示节点 $x$ 的父节点。

有序点对 $(u,v)$ 的距离为 $2$，显然分两种：

* $v$ 的父节点 $f_v$ 是 $u$ 的子节点，即 $u=f_{f_v}$；$v=f_{f_u}$。

  这只需要 DFS 一遍，DFS 到当前节点 $x$ 时维护 $x$ 的父节点 $f_x$ 和 $x$ 的子节点计算贡献即可。

  这一部分总时间复杂度：$\mathcal O(n)$。

* $u,v$ 有共同父节点 $f_u=f_v$。

  记 $x=f_u$，$y_1,y_2,\cdots,y_k$ 为 $x$ 的子节点。

  则有：

  $$
  \sum_{i=1}^k\sum_{j=1}^k[i\neq j]w_{y_i}w_{y_j}=\sum_{i=1}^kw_i\left(\sum_{j=1}^kw_{y_j}-w_{y_i}\right)
  $$

  容易发现 $\sum\limits_{j=1}^kw_{y_j}$ 是定值，那么预处理出来，就可以 $\mathcal O(1)$ 计算。

  这一部分总时间复杂度：$\mathcal O(n)$。

那么，我们就在 $\mathcal O(n)$ 的时间内做完了这道题。事实上，可以枚举每一个点作为根节点的时候的子节点之间的贡献，只有一种情况，但是本质相同。

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef long long ll;
constexpr const int N=2e5,W=10000,P=10007;
int n,w[N+1],sum,Max;
vector<int>g[N+1];
void dfs(int x,int fx){
	vector<int>childW;
	for(int i:g[x]){
		if(i==fx){
			continue;
		}
		dfs(i,x);
		Max=max(Max,w[i]*w[fx]);
		sum=(sum+2*w[i]*w[fx])%P;
		childW.push_back(w[i]);
	}
	if(childW.size()>=2){
    	//其实可以不用排序，但是我懒
		sort(childW.begin(),childW.end(),[](int a,int b){
			return a>b;
		});
		Max=max(Max,childW[0]*childW[1]);
		ll sumW=0;
		for(int i:childW){
			sumW+=i;
		}
		for(int i:childW){
			sum=(sum+i*(sumW-i))%P;
		}
	}
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	for(int i=1;i<=n;i++){
		cin>>w[i];
	}
	dfs(1,0);
	cout<<Max<<' '<<sum<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

> [[NOIP 2014 普及组] 子矩阵](https://www.luogu.com.cn/problem/P2258)

首先注意到数据范围较小，$1\leq n,m\leq16$。

但是考虑到，如果暴力选出 $r$ 行 $c$ 列，仍会超时。当 $n=m=2r=2c=16$ 时，选出的数据量级约为 $1.7\times10^8$，更何况还要计算答案。因此考虑 DP 优化求解。

首先暴力选出 $r$ 行，记为 $\textit{row}_1,\textit{row}_2,\cdots,\textit{row}_r$。

设 $\textit{dp}_{i,j}$ 表示在 $1\sim i$ 列中，恰好选出 $j$ 列，且第 $i$ 列必须选的子矩阵最小分值。

则有：

$$
\textit{dp}_{i,j}=\min_{k=j-1}^{i-1}\textit{dp}_{k,j-1}+\operatorname{calc}(k,i)
$$

即枚举在 $1\sim k$ 列中选出 $j-1$ 列，加上第 $k$ 列右边加上 $i$ 列造成的贡献 $\operatorname{calc}(k,i)$。

分步计算第 $i$ 列内部的贡献及与第 $k$ 列的行间贡献，有：

$$
\begin{aligned}
\operatorname{calc}(x,y)=\sum_{i=1}^{r-1}\vert a_{\textit{row}_i,y}-a_{\textit{row}_{i+1},y}\vert+\sum_{i=1}^r\vert a_{\textit{row}_i,x}-a_{\textit{row}_i,y}\vert
\end{aligned}
$$

故，可以 $\mathcal O\left(\dbinom{n}{r}m^2cr\right)$ 计算答案。

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=16,M=16;
int n,m,r,c,a[N+1][M+1];
int ans=2147483647;
//选的行 
int row[N+1];
int calc(int x,int y){
	int ans=0;
	for(int i=1;i<r;i++){
		ans+=abs(a[row[i]][y]-a[row[i+1]][y]);
	}
	for(int i=1;i<=r;i++){
		ans+=abs(a[row[i]][x]-a[row[i]][y]);
	}
	return ans;
}
void Dp(){
	static int dp[M+1][M+1];
	memset(dp,0x3f,sizeof(dp));
	for(int i=1;i<=m;i++){
		dp[i][1]=0;
		for(int j=1;j<r;j++){
			dp[i][1]+=abs(a[row[j]][i]-a[row[j+1]][i]);
		}
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=i&&j<=c;j++){
			for(int k=j-1;k<i;k++){
				dp[i][j]=min(dp[i][j],dp[k][j-1]+calc(k,i));
			}
		}
	}
	for(int i=1;i<=m;i++){
		ans=min(ans,dp[i][c]);
	}
}
void choose(int p,int choosed){
	if(choosed==r){
		Dp();
		return;
	}
	if(p>n){
		return;
	}
	if(n-p+1+choosed<r){
		return;
	}
	row[choosed+1]=p;
	choose(p+1,choosed+1);
	row[choosed+1]=0; 
	choose(p+1,choosed);
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>m>>r>>c;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	choose(1,0);
	cout<<ans<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

> [[NOIP 2014 提高组] 飞扬的小鸟](https://www.luogu.com.cn/problem/P1941)

设 $\textit{dp}_{i,j}$ 表示走到 $(i,j)$ 的最小点击屏幕数。若 $(i,j)$ 不在游戏范围内或在管道范围内，则默认 $\textit{dp}_{i,j}=+\infty$。

特别地，对于 $1\leq j\leq m$，有 $\textit{dp}_{0,j}=0$。

* 若从 $i-1$ 下降 $y_{i-1}$ 到达 $(i,j)$，有 $\textit{dp}_{i,j}=\textit{dp}_{i-1,j+y_{i-1}}$。
* 若从 $i-1$ 上升，需要分类讨论。设在 $i-1$ 点击了 $k$ 次，上升了 $kx_{i-1}$。
  * 若 $j<m$，有 $\textit{dp}_{i,j}=\textit{dp}_{i-1,j-kx_{i-1}}+1$。
  * 否则若 $j=m$，有 $\textit{dp}_{i,m}=\min\limits_{j'=m-kx_{i-1}}^m\textit{dp}_{i-1,j'}+1$。

进行一些优化，即可 $\mathcal O(nm)$ 计算。

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef long long ll;
constexpr const int MAXN=10001,MAXM=1001;
constexpr const ll INF=1ll<<62;
typedef long long ll;
int read()
{
    int ret = 0;
    char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') ret = ret * 10 + c - '0', c = getchar();
    return ret;
}

int N, M, K, X[MAXN], Y[MAXN], L[MAXN], H[MAXN];
ll dp[MAXN][MAXM], ans[MAXN];
bool W[MAXN];
int main(){
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
	
    N = read(), M = read(), K = read();
    int i, j, x;
    for (i = 0; i < N; ++i) X[i] = read(), Y[i] = read();
    for (i = 1; i <= K; ++i) x = read(), L[x] = read(), H[x] = read(), W[x] = 1;
    for (i = 0; i <= M; ++i) dp[0][i] = 0;
    for (i = 1; i <= N; ++i) dp[i][0] = INF;
    for (i = 1; i <= N; ++i)
    {
    	ans[i] = INF;
    	for (j = 1; j <= M; ++j) dp[i][j] = INF;
    	for (j = X[i - 1] + 1; j < M; ++j) dp[i][j] = min(dp[i][j], min(dp[i - 1][j - X[i - 1]], dp[i][j - X[i - 1]]) + 1);
    	for (j = M - X[i - 1]; j <= M; ++j) dp[i][M] = min(dp[i][M], min(dp[i - 1][j], dp[i][j]) + 1);
    	for (j = 1; j + Y[i - 1] <= M; ++j) dp[i][j] = min(dp[i][j], dp[i - 1][j + Y[i - 1]]);
    	if (W[i])
    	{
    		for (j = 1; j <= L[i]; ++j) dp[i][j] = INF;
    		for (j = H[i]; j <= M; ++j) dp[i][j] = INF;
    	}
        
    	for (j = 1; j <= M; ++j) ans[i] = min(ans[i], dp[i][j]);
    	if (ans[i] == INF)
    	{
    		ll ac = 0;
    		for (j = 1; j < i; ++j) if (W[j]) ++ac;
    		printf("0\n%lld\n", ac);
    		return 0;
    	}
    }
   	printf("1\n%lld\n", ans[N]);
    
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>



# NOIP2015

> [[NOIP 2015 提高组] 子串](https://www.luogu.com.cn/problem/P2679)

求方案数，考虑 DP。

DP 状态显然需要记录匹配到 $A,B$ 中的位置。同时，为了维护子串数量和字符状态，可以设计 $\textit{dp}_{i,j,k,l},l\in\set{0,1}$，表示用 $A_1,A_2,\cdots,A_i$ 中的 $k$ 个子串，匹配了 $B_1,B_2,\cdots,B_j$，$A_i$ 选与不选的方案数。

则有：

$$
\begin{aligned}
\textit{dp}_{i,j,k,0}&=\textit{dp}_{i-1,j,k,0}+\textit{dp}_{i-1,j,k,1}\\
\textit{dp}_{i,j,k,1}&=
\begin{cases}
\textit{dp}_{i-1,j-1,k,1}+\left(\textit{dp}_{i-1,j-1,k-1,0}+\textit{dp}_{i-1,j-1,k-1,1}\right)&A_i=B_j\\
0&A_i\neq B_j
\end{cases}
\end{aligned}
$$

<details class="success">
    <summary>参考代码</summary>
    <p>
        滚动数组优化即可避免 MLE。
    </p>

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=1000,M=200,K=200,P=1000000007;
int n,m,k;
char a[N+1],b[M+1];
int f[2][M+1][K+1][2];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	scanf("%d %d %d",&n,&m,&k);
	scanf("%s%s",a+1,b+1);
	f[0][0][0][0]=f[1][0][0][0]=1;
	bool mode=0;
	for(int i=1;i<=n;i++){
		mode=!mode;
		for(int j=1;j<=m;j++){
			for(int kk=1;kk<=k;kk++){
				if(a[i]==b[j]){
					f[mode][j][kk][0]=(f[!mode][j][kk][0]+f[!mode][j][kk][1])%P;
					f[mode][j][kk][1]=(1ll*f[!mode][j-1][kk][1]+f[!mode][j-1][kk-1][0]+f[!mode][j-1][kk-1][1])%P;
				}else{
					f[mode][j][kk][0]=(f[!mode][j][kk][0]+f[!mode][j][kk][1])%P;
					f[mode][j][kk][1]=0;
				}
			}
		}
	}
	printf("%d\n",(f[mode][m][k][0]+f[mode][m][k][1])%P);
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

# NOIP2016

> [[NOIP 2016 提高组] 换教室](https://www.luogu.com.cn/problem/P1850)

设 $dp_{i,j,k\in\lbrace0,1\rbrace }$ 表示处理到第 $i$ 个时间段，申请换了（不是实际换了几个） $j$ 个教室，第 $i$ 个教室是否更换的答案。

令 $a_{x,y}$ 表示教室 $x$ 到教室 $y$ 的最短路长度，有：


$$
\begin{aligned}
dp_{i,0,0}&=dp_{i-1,0,0}+a_{c_{i-1},c_i}\\
dp_{i,j,0}&=\min
\begin{cases}
dp_{i-1,j,0}+a_{c_{i-1},c_i}\\
k_{i-1}(dp_{i-1,j,1}+a_{d_{i-1},c_i})+(1-k_{i-1})(dp_{i-1,j,1}+a_{c_{i-1},c_i})
\end{cases}\\
&=\min
\begin{cases}
dp_{i-1,j,0}+a_{c_{i-1},c_i}\\
dp_{i-1,j,1}+a_{d_{i-1},c_i}\cdot k_{i-1}+a_{c_{i-1},c_i}(1-k_{i-1})
\end{cases}
\\
dp_{i,j,1}&=\min
\begin{cases}
dp_{i-1,j-1,0}+a_{c_{i-1},d_i}\cdot k_i+a_{c_{i-1},c_i}(1-k_i)\\
dp_{i-1,j-1,1}+a_{d_{i-1},d_i}\cdot k_{i-1}\cdot k_i+a_{d_{i-1},c_i}\cdot k_{i-1}(1-k_i)+a_{c_{i-1},d_i}(1-k_{i-1})k_i+a_{d_{i-1},d_i}(1-k_{i-1})(1-k_i)
\end{cases}
\end{aligned}
$$

DP 边界为 $dp_{1,0,0}=dp_{1,1,1}=0$。

[详细题解参见此处](./-/P1850)。

<details class="success">
    <summary>参考代码</summary>

```cpp

//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=2000,M=2000,V=300;
constexpr const double Max=1e18;
int n,m,v,e,c[N+1],d[N+1],a[V+1][V+1];
double k[N+1],dp[N+1][M+1][2];
template<typename T>
T min(T a,T b,T c){
	return (a<b?(a<c?a:c):(b<c?b:c));
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>m>>v>>e;
	for(int i=1;i<=n;i++){
		cin>>c[i];
	}
	for(int i=1;i<=n;i++){
		cin>>d[i];
	}
	for(int i=1;i<=n;i++){
		cin>>k[i];
	}
	memset(a,0x3f,sizeof(a));
	for(int i=1;i<=e;i++){
		int u,v,w;
		cin>>u>>v>>w;
		a[u][v]=a[v][u]=min(a[u][v],w);
	}
	for(int k=1;k<=v;k++){
		for(int i=1;i<=v;i++){
			for(int j=1;j<=v;j++){
				a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
			}
		}
	}
	for(int i=0;i<=v;i++){
		a[i][i]=0;
	}
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m;j++){
			dp[i][j][0]=dp[i][j][1]=Max;
		}
	}
	dp[1][0][0]=dp[1][1][1]=0;
	for(int i=2;i<=n;i++){
		dp[i][0][0]=dp[i-1][0][0]+a[c[i-1]][c[i]];
		for(int j=1;j<=i&&j<=m;j++){ 
			dp[i][j][0]=min(
				dp[i-1][j][0]+a[c[i-1]][c[i]],
				dp[i-1][j][1]+a[d[i-1]][c[i]]*k[i-1]+a[c[i-1]][c[i]]*(1-k[i-1])
			); 
			dp[i][j][1]=min(
				dp[i-1][j-1][0]+a[c[i-1]][d[i]]*k[i]+a[c[i-1]][c[i]]*(1-k[i]),
				dp[i-1][j-1][1]+a[d[i-1]][d[i]]*k[i-1]*k[i]+a[d[i-1]][c[i]]*k[i-1]*(1-k[i])+a[c[i-1]][d[i]]*(1-k[i-1])*k[i]+a[c[i-1]][c[i]]*(1-k[i-1])*(1-k[i]) 
			);
		}
	}
	double ans=Max;
	for(int i=0;i<=m;i++){
		ans=min(ans,dp[n][i][0],dp[n][i][1]);
	}
	cout<<fixed<<setprecision(2)<<ans<<'\n';
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

> [[NOIP 2016 提高组] 愤怒的小鸟](https://www.luogu.com.cn/problem/P2831)

注意到 $n\leq18$，因此可以考虑**状压 DP**。

设 $\textit{dp}_s$ 表示射死的猪的集合为 $s$ 时的方案数。

记 $\textit{line}_{i,j}$ 表示射死第 $i,j$ 只猪的合法的抛物线射死的猪的状态。

有：

$$
\textit{dp}_{s\cup\textit{line}_{i,j}}\leftarrow\min(\textit{dp}_{s\cup\textit{line}_{i,j}},\textit{dp}_s+1)
$$

[详细题解参见此处](./-/P2831)。

<details class="success">
    <summary>参考代码</summary>

```cpp

//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=18;
constexpr const double eps=1e-6;
int n,dp[1<<N|1],line[N+1][N+1];
struct node{
	double x,y;
}a[N+1];
struct func{
	double a,b;
};
func calc(node a,node b){
	double& x1=a.x,x2=b.x,y1=a.y,y2=b.y; 
	func ans;
	ans.a=(x2*y1-x1*y2)/(x1*x2*(x1-x2));
	ans.b=y1/x1-ans.a*x1;
	return ans;
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	int T;
	cin>>T;
	while(T--){
		int m;
		cin>>n>>m;
		for(int i=0;i<n;i++){
			cin>>a[i].x>>a[i].y;
		}
		memset(line,0,sizeof(line));
		for(int i=0;i<n;i++){
			line[i][i]|=(1<<i);
			for(int j=0;j<n;j++){
				if(i==j){
					continue;
				} 
				auto pl=calc(a[i],a[j]);
				if(pl.a>=0){
					continue;
				}
				for(int k=0;k<n;k++){
					if(abs(a[k].y-(pl.a*a[k].x*a[k].x+pl.b*a[k].x))<=eps){
						line[i][j]|=(1<<k);
					}
				}
			}
		}
		memset(dp,0x3f,sizeof(dp));
		dp[0]=0;
		for(int i=0;i<(1<<n);i++){
			for(int j=0;j<n;j++){
				for(int k=0;k<n;k++){
					dp[i|line[j][k]]=min(dp[i|line[j][k]],dp[i]+1);
				}
			}
		}
		cout<<dp[(1<<n)-1]<<'\n';
	}
	
	cout.flush();
	 
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

# NOIP2017

> [[NOIP 2017 普及组] 跳房子](https://www.luogu.com.cn/problem/P3957)

花费金币越多，灵活性越高，能够到达的格子越多，获得分数越高。

因此答案具有单调性，可以二分花费的金币数 $g$。

设 $\textit{dp}_i$ 为跳到第 $i$ 个格子获得的最大分数，使用单调队列优化 DP 维护转移即可。

转移有：

$$
dp_i=s_i+\max_{x_i-d-g\leq x_j\leq x_i+\max(1,d-g)} dp_j
$$

[详细题解参见此处](./-/P3957)。

<details class="success">
    <summary>参考代码</summary>

```cpp

//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef long long ll;
constexpr const int N=5e5,S=1e5;
struct grid{
	int x,s;
}a[N+1];
int n,d,k;
bool noAns(){
	ll sum=0;
	for(int i=1;i<=n;i++){
		if(a[i].s>0){
			sum+=a[i].s;
		}
	}
	return sum<k;
}
//跳到i时的最大分数 
ll dp[N+1];
bool check(int g){
	fill(dp+1,dp+n+1,-1ll*N*S-1);
	deque<int>q;
	q.push_back(0);
	for(int i=1,p=0;i<=n;i++){
		while(a[p].x<=a[i].x-max(1,d-g)){
			while(q.size()&&dp[q.back()]<=dp[p]){
				q.pop_back();
			}
			q.push_back(p++);
		}
		while(q.size()&&(a[q.front()].x<a[i].x-d-g||a[i].x-max(1,d-g)<a[q.front()].x)){
			q.pop_front();
		}
		if(q.size()){
			dp[i]=dp[q.front()]+a[i].s;
			if(dp[i]>=k){
				return true;
			}
		}
		/*for(int j=0;j<i;j++){
			if(a[i].x-d-g<=a[j].x&&a[j].x<=a[i].x-max(1,d-g)){
				dp[i]=max(dp[i],dp[j]);
			}
		}
		dp[i]+=a[i].s;
		*/
	}
	return false;
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>d>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].s;
	}
	if(noAns()){
		cout<<-1<<'\n';
	}else{
		int l=0,r=max(a[n].x,d);
		while(l<r){
			int mid=l+r>>1;
			if(check(mid)){
				r=mid;
			}else{
				l=mid+1;
			}
		}
		cout<<r<<'\n';
	}
	
	cout.flush();
	 
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

> [[NOIP 2017 提高组] 逛公园](https://www.luogu.com.cn/problem/P3953)

令 $\textit{dis}_i$ 表示从 $1$ 走到 $i$ 的最短路。

考虑设计 DP 求解。设 $\textit{dp}_{u,k}$ 表示从 $1$ 走到 $u$，且总路径长度不超过 $\textit{dis}_u+k$ 的路径数量。

有：

$$
\textit{dp}_{u,k}=\sum_{v\in V_u}\textit{dp}_{v,\textit{dis}_u+k-w_{u,v}-\textit{dis}_v}
$$

同时在 DFS 求解过程中，记 $\textit{vis}_{u,k}$ 表示状态 $[u,k]$ 是否出现过，若出现了，则有 $0$ 环。

[详细题解参见此处](./-/P3953)。

<details class="success">
    <summary>参考代码</summary>

```cpp

//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=1e5,M=2e5,Kmax=50;
struct graph{
	struct edge{
		int v,r,w;
	}a[M+1];
	int size,h[N+1];
	void clear(){
		size=0;
		memset(h,0,sizeof(h));
	}
	void create(int u,int v,int w){
		a[++size]={v,h[u],w};
		h[u]=size;
	}
}g,rg;
int n,m,K,P;
int dis[N+1];
int Dijkstra(int s,int t){
	memset(dis,0x3f,sizeof(dis));
	static bool vis[N+1];
	memset(vis,0,sizeof(vis));
	dis[s]=0;
	priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;
	q.push({dis[s],s});
	while(q.size()){
		int x=q.top().second;q.pop();
		if(vis[x]){
			continue;
		}
		vis[x]=true;
		for(int i=g.h[x];i;i=g.a[i].r){
			int &v=g.a[i].v;
			if(vis[v]){
				continue;
			}
			if(dis[x]+g.a[i].w<dis[v]){
				dis[v]=dis[x]+g.a[i].w;
				q.push({dis[v],v});
			}
		}
	}
	return dis[t];
}
bool vis[N+1][Kmax+1];
int dp[N+1][Kmax+1];
bool ring0;
int f(int u,int k){
	if(ring0){
		return -1;
	}
	if(k<0||K<k){
		return 0;
	}
	if(vis[u][k]){
		ring0=true;
		return -1;
	}
	vis[u][k]=true;
	if(dp[u][k]){
		vis[u][k]=false;
		return dp[u][k];
	}
	for(int i=rg.h[u];i;i=rg.a[i].r){
		int &v=rg.a[i].v,&w=rg.a[i].w;
		dp[u][k]=(1ll*dp[u][k]+f(v,dis[u]+k-dis[v]-w))%P;
	}
	if(u==1&&k==0){
		vis[u][k]=false;
		return 1;
	}
	vis[u][k]=false;
	return dp[u][k];
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	int T;
	cin>>T;
	while(T--){
		g.clear();
		rg.clear();
		memset(dp,0,sizeof(dp));
		memset(vis,0,sizeof(vis));
		
		cin>>n>>m>>K>>P;
		while(m--){
			int u,v,w;
			cin>>u>>v>>w;
			g.create(u,v,w);
			rg.create(v,u,w);
		}
		Dijkstra(1,n);
		ring0=false;
		f(n,K);
		if(ring0){
			cout<<"-1\n";
		}else{
			int ans=0;
			for(int i=0;i<=K;i++){
				ans=(1ll*ans+f(n,i))%P;
			} 
			cout<<ans<<'\n';
		}
	}
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>



> [[NOIP 2017 提高组] 宝藏](https://www.luogu.com.cn/problem/P3959)

因为 $1\leq n\leq12$，因此可以设计指数级算法（一般是搜索或状压 DP），考虑状压 DP。

设 $\textit{dp}_{i,s}$ 表示当前打通的宝藏屋的集合为 $s$，$s$ 中的宝藏屋最大深度为 $i$ 时的最小代价，答案即：

$$
\min\limits_{i=0}^n\textit{dp}_{i,\mathbb N\cap[0,n-1]}
$$

枚举 $j$ 的非空真子集 $k$，设 $f_{k,j}$ 表示从状态为 $k$ 打通到 $j$ 的最小边权和，$\textit{can}_{k,j}$ 表示能否从 $k$ 打通到 $j$，有：

$$
\textit{dp}_{i,j}=\min_{k\subsetneq j,\textit{can}_{k,j}=1}(\textit{dp}_{i-1,k}+i\cdot f_{k,j})
$$

[详细题解参见此处](./-/P3959)。

<details class="success">
    <summary>参考代码</summary>

```cpp

//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=12,inf=0x3f3f3f3f;
int n,g[N+1][N+1],dp[N+1][1<<N|1],f[1<<N|1][1<<N|1],can[1<<N|1][1<<N|1],edge[1<<N|1];
string binary(int x){
	string ans;
	while(x){
		ans+=(x&1)^'0';
		x>>=1;
	}
	reverse(ans.begin(),ans.end());
	return ans;
}
main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	int m;
	cin>>n>>m;
	memset(g,0x3f,sizeof(g));
	while(m--){
		int u,v,w;
		cin>>u>>v>>w;
		u--,v--;
		g[u][v]=g[v][u]=min(g[u][v],w);
	}
	for(int s=0;s<(1<<n);s++){
		edge[s]=s;
		for(int i=0;i<n;i++){
			if(s&(1<<i)){
				for(int j=0;j<n;j++){
					if(g[i][j]<inf){
						edge[s]|=1<<j;
					}
				}
			}
		}
	}
	//从 j 转移到 i 的最小边权和 
	for(int i=0;i<(1<<n);i++){
		for(int j=(i-1)&i;j;j=(j-1)&i){
			//j 转移能到 i 的所有点 
			if((i&edge[j])==i){
				can[j][i]=true;
				static int tmp[N+1];
				fill(tmp,tmp+n,inf);
				for(int k=0;k<n;k++){
					if(j&(1<<k)){
						for(int l=0;l<n;l++){
							if((i&(1<<l)) && !(j&(1<<l))){
								tmp[l]=min(tmp[l],g[k][l]);
							}
						}
					}
				}
				for(int k=0;k<n;k++){
					if((i&(1<<k)) && !(j&(1<<k))){
						if(tmp[k]==inf){
							can[j][i]=false;
							break;
						}
						f[j][i]+=tmp[k];
					}
				}
			}else{
				can[j][i]=false;
			}
		}
	}
	memset(dp,0x3f,sizeof(dp));
	for(int i=0;i<n;i++){
		dp[0][1<<i]=0;
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<(1<<n);j++){
			for(int k=(j-1)&j;k;k=(k-1)&j){
				if(can[k][j]){
					dp[i][j]=min(dp[i][j],dp[i-1][k]+i*f[k][j]);
				}
			}
		}
	}
	int ans=2147483647;
	for(int i=0;i<=n;i++){
		ans=min(ans,dp[i][(1<<n)-1]);
	}
	cout<<ans<<'\n';
	
	cout.flush();
	 
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

# NOIP2018

> [[NOIP 2018 提高组] 货币系统](https://www.luogu.com.cn/problem/P5020)

即从 $a_1,a_2,\cdots,a_n$ 中找出最少的 $m$ 个整数，使得这 $m$ 个整数均不能被其他整数表示出来。

因此可以设 $\textit{dp}_{i,j}$ 表示使用 $a_1,a_2,\cdots,a_i$ 表示出 $j$ 的方案数，就是一个完全背包问题。

记 $V=\max\limits_{i=1}^na_i$，答案即：

$$
\sum_{i=1}^{V}[\textit{dp}_{n,i}=1]
$$

<details class="success">
    <summary>参考代码</summary>
    <p>
        使用的是一维数组的完全背包。
    </p>

```cpp
#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
#include<set>
using namespace std;
constexpr const int N=100,V=25000;
int n,a[N+1],dp[V+1];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	int T;
	scanf("%d",&T);
	while(T--){
		memset(dp,0,sizeof(dp));
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d",a+i);
			dp[a[i]]++;
		}
		for(int i=1;i<=V;i++){
			for(int j=1;j<=n;j++){
				if(i>a[j]&&dp[i-a[j]]){
					dp[i]++;
				}
			}
		}
		int ans=0;
		for(int i=1;i<=n;i++){
			if(dp[a[i]]==1){
				ans++;
			}
		}printf("%d\n",ans);
	} 
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

> [[NOIP 2018 普及组] 摆渡车](https://www.luogu.com.cn/problem/P5017)

令 $t$ 从小到大有序，设 $dp_{i,j}$ 表示前 $i$ 个人在第 $i$ 个人等待了 $j$ 时刻时全部上车的最短时间。

枚举一个 $k$，表示前 $i+k$ 个人都上车，且第 $i+1\sim i+k$ 个人一起上车。
则可以计算得出第 $i+k$ 个人的等待时间：
$$
pl=\max((t_i+j)+m-t_{i+k},0)
$$


可以得到：

$$
dp_{i+k,pl}\leftarrow\min\left(dp_{i+k,pl},dp_{i,j}+k(t_{i+k}+pl)-\sum_{l=i+1}^{i+k}t_i\right)
$$

很明显，做一个 $t$ 的前缀和即可单次实现 $\mathcal O(1)$ 转移，总转移复杂度 $\mathcal O(n)$。

[详细题解参见此处](./-/P5017)。

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=500,M=100,T=4e6;
int n,m,t[N+1],sum[N+1],dp[N+1][M+1];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>t[i];
	}
	sort(t+1,t+n+1);
	for(int i=1;i<=n;i++){
		sum[i]=sum[i-1]+t[i];
	}
	memset(dp,0x3f,sizeof(dp));
	t[0]=-(1<<30);
	dp[0][0]=0;
	for(int i=0;i<=n;i++){
//		cerr<<"min("<<m-1<<","<<t[i+1]<<"-"<<t[i]<<")="<<min(m-1,t[i+1]-t[i])<<endl;
		for(int j=0;j<=min(m-1,t[i+1]-t[i]);j++){
//			cerr<<"dp on "<<i<<","<<j<<":\n";
//			cerr<<"dp["<<i<<"]["<<j<<"]="<<dp[i][j]<<endl;
			for(int k=1;i+k<=n;k++){
//				cerr<<"k="<<k<<endl;
				int pl=max(t[i]+j+m-t[i+k],0);
//				cerr<<"pl="<<pl<<endl;
				dp[i+k][pl]=min(dp[i+k][pl],dp[i][j]+k*(pl+t[i+k])-(sum[i+k]-sum[i]));
//				cerr<<"dp["<<i+k<<"]["<<pl<<"]="<<dp[i+k][pl]<<endl;
			}
		}
	}
	int ans=dp[n][0];
	for(int i=1;i<m;i++){
		ans=min(ans,dp[n][i]);
	}
	cout<<ans<<'\n';
	
	cout.flush();
	 
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

> [[NOIP 2018 提高组] 填数游戏](https://www.luogu.com.cn/problem/P5023)

发现 $n,m$ 没有区别，但是 $n\leq8,m\leq10^6$，应该有一些性质可以利用。

考虑打表，于是有：

```cpp
int f[9][9]={
	{0,0,0,0,0,0,0,0,0},
	{0,2,4,8,16,32,64,128,256},
	{0,4,12,36,108,324,972,2916,8748},
	{0,8,36,112,336,1008,3024,9072,27216},
	{0,16,108,336,912,2688,8064,24192,72576},
	{0,32,324,1008,2688,7136,21312,63936,191808},
	{0,64,972,3024,8064,21312,56768,170112,510336},
	{0,128,2916,9072,24192,63936,170112,453504,1360128},
	{0,256,8748,27216,72576,191808,510336,1360128,3626752}
};
```

记 $\textit{ans}_{n,m}$ 为 $n$ 行 $m$ 列的棋盘的答案，钦定 $n\leq m$，则有：

* $n=1$ 时，$\textit{ans}_{n,m}=2^m$。
* $n>1$ 时，$\textit{ans}_{n,m}=3\cdot\textit{ans}_{n,m-1}$。

<details class="success">
    <summary>参考代码</summary>

```cpp

//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef long long ll;
constexpr const int N=8,M=1e6,P=1e9+7;
int n,m;
int f[N+1][N+1]={
	{0,0,0,0,0,0,0,0,0},
	{0,2,4,8,16,32,64,128,256},
	{0,4,12,36,108,324,972,2916,8748},
	{0,8,36,112,336,1008,3024,9072,27216},
	{0,16,108,336,912,2688,8064,24192,72576},
	{0,32,324,1008,2688,7136,21312,63936,191808},
	{0,64,972,3024,8064,21312,56768,170112,510336},
	{0,128,2916,9072,24192,63936,170112,453504,1360128},
	{0,256,8748,27216,72576,191808,510336,1360128,3626752}
};
int qpow(int base,int n){
	int ans=1;
	while(n){
		if(n&1){
			ans=1ll*ans*base%P;
		}
		base=1ll*base*base%P;
		n>>=1;
	}
	return ans;
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>m;
	if(n>m){
		swap(n,m);
	}
	if(n==1){
		cout<<qpow(2,m)<<'\n';
	}else if(m-1<=N){
		cout<<f[n][m]<<'\n';
	}else{
		int ans;
		if(n!=8){
			ans=f[n][n+1];
		}else{
			ans=10879488;
		}
		for(int i=1;i<=m-n-1;i++){
			ans=3ll*ans%P;
		}
		cout<<ans<<'\n';
	}
	
	cout.flush();
	 
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

> [[NOIP 2018 提高组] 保卫王国](https://www.luogu.com.cn/problem/P5024)

题目即求出**最小权覆盖集**，记为 $S$。

记全集为 $U$，**最大权独立集**为 $T$，则有：

$$
S=\complement_UT
$$

因此考虑求出 $S$ 即可，使用 [DDP](./-/DDP#ddp-维护树上信息) 可 $\mathcal O\left(n\log ^2n\right)$ 或 $\mathcal O(n\log n)$ 求解。

<details class="success">
    <summary>参考代码</summary>

```cpp

//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
#define int long long
//#define DEBUG 
constexpr const int N=1e5,inf=0x3f3f3f3f3f3f3f3fll;
int n,a[N+1];
int f[N+1][2],g[N+1][2];
vector<int>edge[N+1];
struct Matrix{
	int n,m;
	int a[2][2];
	Matrix(int nn=0,int mm=-1){
		if(mm==-1){
			mm=nn;
		}
		n=nn,m=mm;
	}
	void unit(){
		for(int i=0;i<n;i++){
			for(int j=0;j<m;j++){
				a[i][j]=-inf;
			}
			a[i][i]=0;
		}
	}
};
Matrix operator*(Matrix A,Matrix B){
	Matrix C(A.n,B.m);
	for(int i=0;i<C.n;i++){
		for(int j=0;j<C.m;j++){
			C.a[i][j]=-inf;
			for(int k=0;k<A.m;k++){
				C.a[i][j]=max(C.a[i][j],A.a[i][k]+B.a[k][j]);
			}
		}
	}
	return C;
}
Matrix& operator*=(Matrix &A,Matrix B){
	return A=A*B;
}
namespace hld{
	int size[N+1],father[N+1],son[N+1];
	void dfs1(int x,int fx){
		father[x]=fx;
		size[x]=1;
		for(int i:edge[x]){
			if(i==fx){
				continue;
			}
			dfs1(i,x);
			size[x]+=size[i];
			if(size[i]>size[son[x]]){
				son[x]=i;
			}
		}
	}
	int top[N+1],bottom[N+1],dfn[N+1],rnk[N+1];
	void dfs2(int x,int topx){
		top[x]=topx;
		static int cnt;
		dfn[x]=++cnt;
		rnk[cnt]=x;
		if(son[x]){
			dfs2(son[x],topx);
			bottom[x]=bottom[son[x]];
			for(int i:edge[x]){
				if(i==father[x]||i==son[x]){
					continue;
				}
				dfs2(i,i);
			}
		}else{
			bottom[x]=x;
		}
	}
	void build(){
		dfs1(1,0);
		dfs2(1,1);
	}
	struct segTree{
		struct node{
			Matrix value;
			int l,r;
		}t[N<<2|1];
		
		Matrix create(int x){
			Matrix ans(2);
			ans.a[0][0]=ans.a[0][1]=g[x][0];
			ans.a[1][0]=g[x][1];
			ans.a[1][1]=-inf;
			return ans;
		}
		void up(int p){
			t[p].value=t[p<<1].value*t[p<<1|1].value;
		}
		void build(int p,int l,int r){
			t[p].l=l,t[p].r=r;
			if(l==r){
				t[p].value=create(rnk[l]);
				return;
			}
			int mid=l+r>>1;
			build(p<<1,l,mid);
			build(p<<1|1,mid+1,r);
			up(p);
		}
		Matrix query(int p,int l,int r){
			if(r<l){
				Matrix ans(2);
				ans.unit();
				return ans;
			}
			if(l<=t[p].l&&t[p].r<=r){
				return t[p].value;
			}
			Matrix ans(2);
			ans.unit();
			if(l<=t[p<<1].r){
				ans*=query(p<<1,l,r);
			}
			if(t[p<<1|1].l<=r){
				ans*=query(p<<1|1,l,r);
			}
			return ans;
		}
		void change(int p,int x){
			if(t[p].l==t[p].r){
				t[p].value=create(rnk[x]);
				return;
			}
			if(x<=t[p<<1].r){
				change(p<<1,x);
			}else{
				change(p<<1|1,x);
			}
			up(p);
		}
	}segTree;
	
	void change(int x,int y){
		g[x][1]+=-a[x]+y;
		a[x]=y;
		segTree.change(1,dfn[x]);
		x=top[x];
		while(x!=1){
			Matrix pl(2,1);
			pl.a[0][0]=0;
			pl.a[1][0]=a[bottom[x]];
			pl=segTree.query(1,dfn[x],dfn[bottom[x]]-1)*pl;
			int fx0=f[x][0],fx1=f[x][1];
			f[x][0]=pl.a[0][0];
			f[x][1]=pl.a[1][0];
			g[father[x]][0]+=max(f[x][0],f[x][1])-max(fx0,fx1);
			g[father[x]][1]+=f[x][0]-fx0;
			segTree.change(1,dfn[father[x]]);
			x=top[father[x]];
		}
	}
	int query(){
		Matrix pl(2,1);
		pl.a[0][0]=0;
		pl.a[1][0]=a[bottom[1]];
		if(1<=dfn[bottom[1]]-1){
			pl=segTree.query(1,1,dfn[bottom[1]]-1)*pl;
		}
		return max(pl.a[0][0],pl.a[1][0]);
	}
}

int depth[N+1];
void dfs(int x,int fx){
	depth[x]=depth[fx]+1;
	for(int i:edge[x]){
		if(i==fx){
			continue;
		}
		dfs(i,x);
		f[x][0]+=max(f[i][0],f[i][1]);
		f[x][1]+=f[i][0];
	}
	f[x][1]+=a[x];
	g[x][0]=f[x][0]-max(f[hld::son[x]][0],f[hld::son[x]][1]);
	g[x][1]=f[x][1]-f[hld::son[x]][0];
}
void pre(){
	hld::build();
	dfs(1,0);
	hld::segTree.build(1,1,n);
}
main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	string type;
	int m;
	cin>>n>>m>>type;
	int sum=0;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum+=a[i];
	}
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	pre();
	while(m--){
		int aa,x,bb,y;
		cin>>aa>>x>>bb>>y;
		bool noAns=false;
		if(!x&&!y){
			for(int i:edge[aa]){
				if(i==bb){
					noAns=true;
					break;
				}
			}
		}
		if(noAns){
			cout<<"-1\n";
			continue;
		}
		if(depth[aa]<depth[bb]){
			swap(aa,bb);
			swap(x,y);
		}
		int ans=0,plA=a[aa],plB=a[bb];
		if(x){
			hld::change(aa,plA-inf);
		}else{
			hld::change(aa,plA+inf);
			ans+=inf;//注意到最大权独立集一定会选 inf，那么这里就要减去 inf 得到正确答案 
		}
		if(y){
			hld::change(bb,plB-inf);
		}else{
			hld::change(bb,plB+inf);
			ans+=inf;
		} 
		ans+=sum-hld::query();
		cout<<ans<<'\n';
		hld::change(aa,plA);
		hld::change(bb,plB);
	}
	
	cout.flush();
	 
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

# NOIP2019

[众所周知](https://www.noi.cn/xw/2019-08-16/715365.shtml)，$2019$ 年是没有 NOIP 的，但是 NOIP 不久就[恢复](https://www.noi.cn/xw/2020-01-21/715520.shtml)了。

# NOIP2020

# NOIP2021

> [[NOIP2021] 数列](https://www.luogu.com.cn/problem/P7961)

称二进制最低位为第 $0$ 位（权值为 $2^0$）。

考虑从小到大填入 $a_i$。

设 $dp_{i,j,k,l}$ 表示处理了 $a_1\sim a_i$，$S$ 能进位到的最高位为 $2^j$（实际上最高位也可以不是 $2^j$，之前的 $a_i$ 最大值为 $j-1$），最高位 $2^j$ 有 $k$ 个，已知 $l$ 位为 $1$ 的答案。
则答案为：
$$
\sum_{\operatorname{count}(k)+l\leq K}dp_{n,m+1,k,l}
$$

从 $dp_{i,j,k,l}$ 向外转移，有：

$$
dp_{i+t,j+1,\left\lfloor\frac{k+t}{2}\right\rfloor,l+(k+t)\bmod 2}\leftarrow dp_{i+t,j+1,\left\lfloor\frac{k+t}{2}\right\rfloor,l+(k+t)\bmod 2}+dp_{i,j,k,l}\cdot v_j^t\cdot \binom{i+t}{t}
$$

边界条件为 $\textit{dp}_{0,0,0,0}=1$。

[详细题解参见此处](./-/P7961)。

<details class="success">
    <summary>参考代码</summary>

```cpp

//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
#include<unordered_map>
using namespace std;
constexpr const int N=30,M=100,K=N,P=998244353;
int n,m,kk,v[M+1];
int dp[N+1][M+1+1][N+1][K+1];
int qpow(int a,int n){
	int base=a,ans=1;
	while(n){
		if(n&1){
			ans=1ll*ans*base%P;
		}
		base=1ll*base*base%P;
		n>>=1;
	}
	return ans;
}
int C(int n,int m){
	static int mem[N+M+1][N+1];
	if(n<m){
		return 0;
	}
	if(m==0||m==n){
		return 1;
	}
	if(mem[n][m]){
		return mem[n][m];
	}
	return mem[n][m]=(1ll*C(n-1,m)+C(n-1,m-1))%P;
}
int count(int x){
	int ans=0;
	while(x){
		if(x&1){
			ans++;
		}
		x>>=1;
	}
	return ans;
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>m>>kk;
	for(int i=0;i<=m;i++){
		cin>>v[i];
	}
	dp[0][0][0][0]=1;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m;j++){
			for(int k=0;k<=n;k++){
				for(int l=0;l<=kk;l++){
					if(dp[i][j][k][l]){
						for(int t=0;i+t<=n;t++){
							int &pl=dp[i+t][j+1][k+t>>1][l+(k+t&1)];
							pl=(1ll*pl+1ll*dp[i][j][k][l]*qpow(v[j],t)%P*C(i+t,t)%P)%P;
						}
					}
				}
			}
		}
	}
	int ans=0;
	for(int k=0;k<=n;k++){
		for(int l=0;l<=kk;l++){
			if(count(k)+l<=kk){
				ans=(1ll*ans+dp[n][m+1][k][l])%P;
			}
		}
	}
	cout<<ans<<'\n';
	
	cout.flush();
	 
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
/*
8 9 4
934258593 150407625 187068439 162292791 219945760 512449588 803393963 983648121 484675481 412407699

642171527
*/
```
</details>

# NOIP2022

> [[NOIP2022] 种花](https://www.luogu.com.cn/problem/P8865)

记 $\textit{line}_{i,j}$ 表示 $(i,j)$ 右边最长的一段 $0$ 的长度，可以通过 DP $\mathcal O\left(n^2\right)$ 求出。同理，记 $\textit{row}_{i,j}$ 表示 $(i,j)$ 下方最长的一段 $0$ 的数量。

那么，$(i,j)$ 对于 `C` 的答案的贡献为：

$$
\sum_{k=i+2}^{i+\textit{row}_{i,j} }\textit{line}_{i,j}\cdot \textit{line}_{k,j}=\textit{line}_{i,j}\sum_{k=i+2}^{i+\textit{row}_{i,j} }\textit{line}_{k,j}
$$

其对于 `F` 的贡献为：

$$
\sum_{k=i+2}^{i+\textit{row}_{i,j} }\textit{line}_{i,j}\cdot \textit{line}_{k,j}\cdot \textit{row}_{k,j}=\textit{line}_{i,j}\sum_{k=i+2}^{i+\textit{row}_{i,j} }\textit{line}_{k,j}\cdot \textit{row}_{k,j}
$$

前缀和优化 DP 即可。

[详细题解参见此处](./-/P8865)。

<details class="success">
    <summary>参考代码</summary>
    <p>写的时候比较懒，写的是 <code>hang</code> 和 <code>lie</code>。</p>

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=1000,M=1000,P=998244353;
int n,m,Vc,Vf;
int a[N+1][M+1],hang[N+1][M+1],lie[N+1][M+1],sumHang[N+1][M+1],sumHangLie[N+1][M+1];
void solve(){
	for(int i=1;i<=n;i++){
		if(a[i][m]){
			hang[i][m]=-1;
		}
		for(int j=m-1;1<=j;j--){
			if(!a[i][j]){
				hang[i][j]=hang[i][j+1]+1;
			}else{
				hang[i][j]=-1;
			} 
		}
	}
	for(int j=1;j<=m;j++){
		if(a[n][j]){
			lie[n][j]=-1;
		}
		for(int i=n-1;1<=i;i--){
			if(!a[i][j]){
				lie[i][j]=lie[i+1][j]+1;
			}else{
				lie[i][j]=-1;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			sumHang[i][j]=(1ll*sumHang[i-1][j]+hang[i][j])%P; 
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			sumHangLie[i][j]=(sumHangLie[i-1][j]+1ll*hang[i][j]*lie[i][j])%P;
		}
	}
	Vc=Vf=0;
	for(int i=1;i+2<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]||a[i+1][j]){
				continue;
			}
			Vc=(Vc+1ll*hang[i][j]*(sumHang[i+lie[i][j]][j]-sumHang[i+1][j])%P)%P;
			Vf=(Vf+1ll*hang[i][j]*(sumHangLie[i+lie[i][j]][j]-sumHangLie[i+1][j])%P)%P;
//			优化如下代码可得 
//			for(int k=i+2;k<=i+lie[i][j];k++){
//				Vc=(Vc+1ll*hang[i][j]*hang[k][j]%P)%P;
//				Vf=(Vf+1ll*hang[i][j]*hang[k][j]%P*lie[k][j]%P)%P;
//			}
		}
	} 
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	int T,id;
	cin>>T>>id;
	while(T--){
		memset(a,0,sizeof(a));
		memset(hang,0,sizeof(hang));
		memset(lie,0,sizeof(lie));
		memset(sumHang,0,sizeof(sumHang));
		memset(sumHangLie,0,sizeof(sumHangLie));
		
		int c,f;
		cin>>n>>m>>c>>f;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				char ch; 
				cin>>ch;
				a[i][j]=ch^'0';
			}
		}
		solve();
		if(Vc<0){
			Vc+=P; 
		}
		if(Vf<0){
			Vf+=P;
		}
		cout<<c*Vc<<' '<<f*Vf<<'\n';
	}
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>



# NOIP2023

# NOIP2024