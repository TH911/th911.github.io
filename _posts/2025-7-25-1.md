---
layout: post
title: "NOIP 二十年 DP 训练总结"
subtitle: "$2005\\sim2024$ NOIP 动态规划真题"
date: 2025-7-25
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 题解
  - 普及−
  - 普及/提高−
  - DP
  - NOIP 二十年 DP 训练
words:
  - "P1048 题解：[NOIP 2005 普及组] 采药"
  - 01 背包01背包
  - "P1060 题解：[NOIP 2006 普及组] 开心的金明"
  - 完全背包
  - "P1077 题解：[NOIP 2012 普及组] 摆花NOIP2012"
  - "P1057 题解：[NOIP 2008 普及组] 传球游戏NOIP2008"
  - NOIP2005NOIP2006NOIP2006NOIP2007NOIP2008NOIP2009NOIP2010NOIP2011NOIP2012NOIP2013NOIP2014NOIP2015NOIP2016NOIP2017NOIP2018NOIP2019NOIP2020NOIP2021NOIP2022NOIP2023NOIP2024
  - "P1095 题解：[NOIP 2007 普及组] 守望者的逃离"
  - "P1970 题解：[NOIP 2013 提高组] 花匠"
  - "P1351 题解：[NOIP 2014 提高组] 联合权值"
---

> 持续更新中，对于较为简单的题目，会直接给出题解。对于较为复杂的题目，会给出**核心摘要**及**详细题解的链接**。

# NOIP2005

> [[NOIP 2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)

经典 01 背包问题。

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
int n,m,w[1001],c[1001],f[1001][1001];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>w[i]>>c[i];
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			f[i][j]=f[i-1][j];
			if(j>=w[i])f[i][j]=max(f[i][j],f[i-1][j-w[i]]+c[i]);
		}
	}
	cout<<f[m][n]<<endl;
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

# NOIP2006


> [[NOIP 2006 普及组] 开心的金明](https://www.luogu.com.cn/problem/P1060)

经典完全背包问题。

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
//v:价格,p:单个乘积,f:Dp数组 
int n,m,v[25],p[25],f[25][30000];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>v[i]>>p[i];
		p[i]*=v[i];
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			f[i][j]=f[i-1][j];
			if(j>v[i])f[i][j]=max(f[i][j],f[i-1][j-v[i]]+p[i]);
		}
	} 
	cout<<f[m][n]<<endl;
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

# NOIP2007

# NOIP2008

> [[NOIP 2008 普及组] 传球游戏](https://www.luogu.com.cn/problem/P1057)

设计状态 $f_{i,j}$ 表示传球 $i$ 次，传球到 $j$ 的方案数，答案为 $f_{m,1}$。

不考虑边界，则有：

$$
f_{i,j}=f_{i-1,j-1}+f_{i-1,j+1}
$$

即从 $j-1,j+1$ 传球到 $j$。 

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef long long ll;
ll n,m,f[31][31];
ll F(int i,int j){
	if(j<1)return f[i][n];
	if(j>n)return f[i][1];
	return f[i][j];
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	scanf("%lld %lld",&n,&m);
	f[0][1]=1; 
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			f[i][j]=F(i-1,j-1)+F(i-1,j+1);
		}
	}printf("%lld\n",f[m][1]);
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

# NOIP2009

# NOIP2010

# NOIP2011

# NOIP2012

> [[NOIP 2012 普及组] 摆花](https://www.luogu.com.cn/problem/P1077)

一个很容易想到的 DP 状态是设 $\textit{dp}_{i,j}$ 表示前 $i$ 种花摆了 $j$ 盆的合法方案数。

则有：

$$
\begin{aligned}
\textit{dp}_{i,j}&=\sum_{k=0}^{\min(a_i,k)}\textit{dp}_{i-1,j-k}\\
\textit{dp}_{0,0}&=1
\end{aligned}
$$

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=100,M=100,P=1e6+7;
int n,m,a[N+1],dp[N+1][M+1];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/

	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=m;j++){
			for(int k=0;k<=a[i]&&k<=j;k++){
				dp[i][j]=(dp[i][j]+dp[i-1][j-k])%P;
			}
		}
	}
	cout<<dp[n][m]<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

# NOIP2013

> [[NOIP 2013 提高组] 花匠](https://www.luogu.com.cn/problem/P1970)

显然，最后剩下的花的高度 $g_1,g_2,g_3,\cdots,g_m$ 需要满足下列性质任意一条：

* $g_1<g_2>g_3<g_4>\cdots$
* $g_1>g_2<g_3>g_4<\cdots$

那么，可以据此设计 $\textit{dp}_{i,j},j\in\set{0,1}$ 表示留下 $g_{i'}=h_i$ 时最多留下的花的数量，且满足：

* $j=0$：$g_{i'-1}>g_{i'}$。
* $j=1$：$g_{i'-1}<g_{i'}$。

则可以写出转移方程：

$$
\begin{aligned}
\textit{dp}_{i,0}&=\max_{h_j>h_i\land j<i}\textit{dp}_{j,1}+1\\
\textit{dp}_{i,1}&=\max_{h_j<h_i\land j<i}\textit{dp}_{j,0}+1\\
\end{aligned}
$$

只需要使用线段树优化 DP，或者树状数组优化 DP 即可。

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
//typedef (*fp)(int,int);
constexpr const int N=2e6,H=1e9;
int n,h[N+1];
int dp[N+1][2];
//前缀最大值 
struct bitPre{
	int t[N+3+1];
	int lowbit(int x){
		return x&-x;
	}
	void set(int x,int k){
		x+=2;
		while(x<=N+3){
			k=max(t[x],k);
			t[x]=k;
			x+=lowbit(x);
		}
	}
	int query(int x){
		x+=2;
		int ans=0;
		while(x){
			ans=max(ans,t[x]);
			x-=lowbit(x);
		} 
		return ans;
	}
}t0;
struct bitSuf{
	int t[N+3+1];
	int lowbit(int x){
		return x&-x;
	}
	void set(int x,int k){
		x+=2;
		while(x){
			k=max(t[x],k);
			t[x]=k;
			x-=lowbit(x);
		} 
	}
	int query(int x){
		x+=2;
		int ans=0;
		while(x<=N+3){
			ans=max(ans,t[x]);
			x+=lowbit(x);
		}
		return ans;
	}
}t1;
void pre(){
	static int tmp[N+1];
	for(int i=1;i<=n;i++){
		tmp[i]=h[i];
	}
	sort(tmp+1,tmp+n+1);
	int len=unique(tmp+1,tmp+n+1)-tmp-1;
	for(int i=1;i<=n;i++){
		h[i]=lower_bound(tmp+1,tmp+len+1,h[i])-tmp;
	}
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>h[i];
	}
	pre();
	for(int i=1;i<=n;i++){
		dp[i][0]=t1.query(h[i]+1)+1;
		dp[i][1]=t0.query(h[i]-1)+1;
		t0.set(h[i],dp[i][0]);
		t1.set(h[i],dp[i][1]);
	}
	int ans=-1;
	for(int i=1;i<=n;i++){
		ans=max({ans,dp[i][0],dp[i][1]});
	}
	cout<<ans<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

# NOIP2014

> [[NOIP 2014 提高组] 联合权值](https://www.luogu.com.cn/problem/P1351)

$n$ 个点却是 $n-1$ 条边，显然是一棵树，令根节点为 $1$。记 $f_x$ 表示节点 $x$ 的父节点。

有序点对 $(u,v)$ 的距离为 $2$，显然分两种：

* $v$ 的父节点 $f_v$ 是 $u$ 的子节点，即 $u=f_{f_v}$；$v=f_{f_u}$。

  这只需要 DFS 一遍，DFS 到当前节点 $x$ 时维护 $x$ 的父节点 $f_x$ 和 $x$ 的子节点计算贡献即可。

  这一部分总时间复杂度：$\mathcal O(n)$。

* $u,v$ 有共同父节点 $f_u=f_v$。

  记 $x=f_u$，$y_1,y_2,\cdots,y_k$ 为 $x$ 的子节点。

  则有：
  
  $$
  \sum_{i=1}^k\sum_{j=1}^k[i\neq j]w_{y_i}w_{y_j}=\sum_{i=1}^kw_i\left(\sum_{j=1}^kw_{y_j}-w_{y_i}\right)
  $$
  
  容易发现 $\sum\limits_{j=1}^kw_{y_j}$ 是定值，那么预处理出来，就可以 $\mathcal O(1)$ 计算。
  
  这一部分总时间复杂度：$\mathcal O(n)$。

那么，我们就在 $\mathcal O(n)$ 的时间内做完了这道题。事实上，可以枚举每一个点作为根节点的时候的子节点之间的贡献，只有一种情况，但是本质相同。

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef long long ll;
constexpr const int N=2e5,W=10000,P=10007;
int n,w[N+1],sum,Max;
vector<int>g[N+1];
void dfs(int x,int fx){
	vector<int>childW;
	for(int i:g[x]){
		if(i==fx){
			continue;
		}
		dfs(i,x);
		Max=max(Max,w[i]*w[fx]);
		sum=(sum+2*w[i]*w[fx])%P;
		childW.push_back(w[i]);
	}
	if(childW.size()>=2){
    	//其实可以不用排序，但是我懒
		sort(childW.begin(),childW.end(),[](int a,int b){
			return a>b;
		});
		Max=max(Max,childW[0]*childW[1]);
		ll sumW=0;
		for(int i:childW){
			sumW+=i;
		}
		for(int i:childW){
			sum=(sum+i*(sumW-i))%P;
		}
	}
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	for(int i=1;i<=n;i++){
		cin>>w[i];
	}
	dfs(1,0);
	cout<<Max<<' '<<sum<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

# NOIP2015

# NOIP2016

# NOIP2017

# NOIP2018

# NOIP2019

[众所周知](https://www.noi.cn/xw/2019-08-16/715365.shtml)，$2019$ 年是没有 NOIP 的，但是 NOIP 不久就[恢复](https://www.noi.cn/xw/2020-01-21/715520.shtml)了。

# NOIP2020

# NOIP2021

# NOIP2022

# NOIP2023

# NOIP2024