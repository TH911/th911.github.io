---
layout: post
title: "斜率优化 DP 详解"
subtitle: "例题：洛谷P3195"
date: 2025-8-19
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 题解
  - 省选/NOI−
  - DP
  - 斜率优化 DP
  - 基础算法
words:
  - "P3195 题解：[HNOI2008] 玩具装箱"
---

> [例题：洛谷 P3195 [HNOI2008] 玩具装箱](https://www.luogu.com.cn/problem/P3195)。
>
> 给定正整数 $n,L$ 和数列 $a_1,a_2,a_3,\cdots,a_n$。$1\leq n\leq5\times10^4$。
>
> 将 $a$ 划分为 $k$ 段，设第 $i$ 段为 $a_{l_i},a_{l_i+1},\cdots,a_{r_i}$，则记 $\displaystyle x_i=r-l+\sum_{t=l}^ra_t$。
>
> 求最小值：
>
> $$
> \sum_{i=1}^k\left(x_i-L\right)^2
> $$
>
> ***
>
> 显然可以 DP，设 $\textit{dp}_i$ 表示划分 $a_1\sim a_i$ 的最小代价。特别地，$\textit{dp}_0=0$。
>
> 记：
> 
> $$
> \textit{pre}_i=\sum_{j=1}^ia_j
> $$
> 
>
> 枚举 $i$ 所在段的左端点 $j$，有：
> 
> $$
> \textit{dp}_i=\min_{j=1}^i\left(\textit{dp}_{j-1}+(i-j+\textit{pre}_i-\textit{pre}_{j-1}-L)^2\right)
> $$
>
> 答案为 $\textit{dp}_n$。时间复杂度：$\mathcal O\left(n^2\right)$，需要优化。

# 递推式的整理

考虑整理上面的递推式：

$$
\begin{aligned}
\textit{dp}_i&=\min_{j=1}^i\left(\textit{dp}_{j-1}+\left(i-j+\textit{pre}_i-\textit{pre}_{j-1}-L\right)^2\right)\\
&=\min_{j=0}^{i-1}\left(\textit{dp}_j+\left(i+\textit{pre}_i-j-\textit{pre}_j-L-1\right)^2\right)\\
&=\min_{j=0}^{i-1}\left(\textit{dp}_j+\left((i+\textit{pre}_i)-\left(j+\textit{pre}_j\right)-(L+1)\right)^2\right)
\end{aligned}
$$

记 $f_i=i+\textit{pre}_i,L'=L+1$，有：

$$
\begin{aligned}
\textit{dp}_i&=\min_{j=0}^{i-1}\left(\textit{dp}_j+\left(f_i-L'-f_j\right)^2\right)\\
&=\min_{j=0}^{i-1}\left(\textit{dp}_j+(f_i-L')^2+f_j^2-2(f_i-L')f_j\right)\\
&=\min_{j=0}^{i-1}\left(\textit{dp}_j+f_j^2-2(f_i-L')f_j\right)+(f_i-L')^2\\
\end{aligned}
$$

考虑对于确定的 $i$，$f_i-L'$ 是**定值**。因此仅仅考虑与 $j$ 相关的部分：

$$
\textit{dp}_j+f_j^2-2(f_i-L')f_j
$$

我们想高效地求出上式的最小值。

# 斜率转化

考虑决策点 $j_1,j_2$，钦定 $j_1<j_2$ 且 $j_1$ 优于 $j_2$，有：

$$
\begin{aligned}
\textit{dp}_{j_1}+f_{j_1}^2-2(f_i-L')f_{j_1}&\leq \textit{dp}_{j_2}+f_{j_2}^2-2(f_i-L')f_{j_2}\\
\textit{dp}_{j_1}+f_{j_1}^2-2(f_i-L')f_{j_1}&\leq \textit{dp}_{j_2}+f_{j_2}^2-2(f_i-L')f_{j_2}\\
-2(f_i-L')(f_{j_1}-f_{j_2})&\leq\textit{dp}_{j_2}+f_{j_2}^2-\left(\textit{dp}_{j_1}+f_{j_1}^2\right)
\end{aligned}
$$

现在考虑 $f_{j_1}-f_{j_2}$ 的**正负性**，这影响到**不等式的变号**。发现钦定了 $0\leq j_1<j_2$，且题目中 $\textit{pre}_i\geq 0$，因此有 $f_{j_1}<f_{j_2}$，即 $f_{j_1}-f_{j_2}<0$。

故，有：

$$
\begin{aligned}
-2(f_i-L')&\geq\dfrac{\left(\textit{dp}_{j_2}+f_{j_2}^2\right)-\left(\textit{dp}_{j_1}+f_{j_1}^2\right)}{f_{j_1}-f_{j_2}}\\
2(f_i-L')&\leq\dfrac{\left(\textit{dp}_{j_1}+f_{j_1}^2\right)-\left(\textit{dp}_{j_2}+f_{j_2}^2\right)}{f_{j_1}-f_{j_2}}\\
\end{aligned}
$$

在此情况下有 $j_1$ 优于 $j_2$。

观察不等式右边 $\dfrac{\left(\textit{dp}_{j_1}+f_{j_1}^2\right)-\left(\textit{dp}_{j_2}+f_{j_2}^2\right)}{f_{j_1}-f_{j_2}}$ 的形式，很像一个东西：

$$
k=\dfrac{y_1-y_2}{x_1-x_2}
$$

即**斜率**。

# 决策点与凸包

因此对于每一个决策点 $j$，可以在平面直角坐标系内得到一个点：

$$
A_j\left(f_j,\textit{dp}_j+f_j^2\right)
$$

在本文中，$A_i$ 一方面代表平面直角坐标系内由 $i$ 相关信息组成的点 $A_i$，另一方面代表决策点 $i$。

记 $x_i=2(f_i-L')$，则决策点 $j_1$ 优于 $j_2$ 的条件重述为：

$$
x_i\leq\dfrac{\left(\textit{dp}_{j_1}+f_{j_1}^2\right)-\left(\textit{dp}_{j_2}+f_{j_2}^2\right)}{f_{j_1}-f_{j_2}}
$$

记 $k_{i,j}$ 表示 $A_iA_j$ 的斜率，则可表述为：

$$
x_i\leq k_{j_1,j_2}
$$

设三个点 $A_1,A_2,A_3$，如果出现了如图所示的情况，则有 $A_2$ 一定不是最优的。（即 $k_{2,3}\leq k_{1,2}$）

![](/img/2025/08/011.png)

假设 $A_2$ 最优，则有：

$$
x_i\leq k_{2,3}
$$

但是考虑到 $k_{2,3}\leq k_{1,2}$，则有 $x_i\leq k_{1,2}$。因此 $A_1$ 优于 $A_2$。故 $A_2$ 一定不是最优的。

这样就可以**直接从平面直角坐标系中删去 $A_2A_3$ 这条线段，即删去 $A_2$，连接 $A_1A_3$**。

最终得到的就是一堆线段，并且满足**斜率单调不降**。因此可以从中找到满足限制条件的最优决策点，并维护新的决策点 $A_i$，将 $A_i$ 加入平面直角坐标系。

这样的操作实际上也就是维护一个**凸壳**。所谓**凸壳**，在斜率优化中即各边斜率单调的图形（其实也可以称为「凸包」，但是不严谨）。如图所示便是一个**下凸壳**（斜率单调不降，也是本题所维护的）：

![](/img/2025/08/012.png)

与之对应的还有**上凸壳**，即斜率单调不升。

# 实现步骤

考虑维护凸壳的具体步骤。使用一个栈来维护凸壳中的点。

1. 寻找最优决策点。

2. 使用最优决策点 $A_j$ 更新当前信息（$\textit{dp}_i$）。

3. 将 $A_i$ 作为新的决策点加入。

   如果 $A_i$ 和栈顶 $A_x$ 构成的线段 $A_xA_i$ 满足 $A_x$ 一定不优，则将 $A_x$ 弹出。

   当无法弹出时，加入 $A_i$。

# 寻找决策点

「寻找最优决策点」这一步一般会有两种方法，使用场景不同，复杂度也不同。

## 二分

凸壳中的斜率单调递增，因此可以二分。时间复杂度 $\mathcal O(\log n)$。

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef long long ll;
constexpr const int N=5e4;
int n,L,a[N+1];
ll pre[N+1],f[N+1],dp[N+1];
struct slopeDP{
	struct node{
		ll x,y;
		int id;
	}q[N+1];
	int front,rear;
	slopeDP(){
		front=1;
		rear=0;
	}
	double slope(node i,node j){
		return (i.y-j.y)/(i.x-j.x);
	}
	void push(int id){
		node x={f[id],dp[id]+f[id]*f[id],id};
		while(front+1<=rear && slope(q[rear],x)<=slope(q[rear-1],q[rear])){
			rear--;
		}
		q[++rear]=x;
	}
	int query(int x){
		int l=front,r=rear-1,ans=rear;
		while(l<=r){
			int mid=l+r>>1;
			if(slope(q[mid],q[mid+1])>=x){
				ans=mid;
				r=mid-1;
			}else{
				l=mid+1;
			}
		} 
		return q[ans].id;
	}
}t;
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>L;
	L++;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		pre[i]=pre[i-1]+a[i];
		f[i]=i+pre[i];
	}
	t.push(0);
	for(int i=1;i<=n;i++){
		int j=t.query(2*(f[i]-L)); 
		dp[i]=dp[j]+f[j]*f[j]-2*(f[i]-L)*f[j];
		dp[i]+=(f[i]-L)*(f[i]-L);
		t.push(i);
	}
	cout<<dp[n]<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>

## 决策单调性

发现决策点 $i$ 的限制条件 $x_i$ 是**单调递增**的，而凸壳中的斜率也是**单调递增**的。因此可以维护指针来代替二分。

其实也就等价于双端队列维护凸壳。

指针移动的总复杂度为 $\mathcal O(n)$，均摊复杂度 $\mathcal O(1)$。

<details class="success">
    <summary>参考代码</summary>

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef long long ll;
constexpr const int N=5e4;
int n,L,a[N+1];
ll pre[N+1],f[N+1],dp[N+1];
struct slopeDP{
	struct node{
		ll x,y;
		int id;
	}q[N+1];
	int front,rear;
	slopeDP(){
		front=1;
		rear=0;
	}
	double slope(node i,node j){
		return (i.y-j.y)/(i.x-j.x);
	}
	void push(int id){
		node x={f[id],dp[id]+f[id]*f[id],id};
		while(front+1<=rear && slope(q[rear],x)<=slope(q[rear-1],q[rear])){
			rear--;
		}
		q[++rear]=x;
	}
	int query(int x){
		while(front+1<=rear && slope(q[front],q[front+1])<=x){
			front++;
		}
		return q[front].id;
	}
}t;
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>L;
	L++;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		pre[i]=pre[i-1]+a[i];
		f[i]=i+pre[i];
	}
	t.push(0);
	for(int i=1;i<=n;i++){
		int j=t.query(2*(f[i]-L)); 
		dp[i]=dp[j]+f[j]*f[j]-2*(f[i]-L)*f[j];
		dp[i]+=(f[i]-L)*(f[i]-L);
		t.push(i);
	}
	cout<<dp[n]<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
</details>
