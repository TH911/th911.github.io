---
layout: post
title: "题解：[POI 2001] 和平委员会"
subtitle: "洛谷 P5782"
date: 2026-2-15
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 题解
  - 提高+/省选−
  - 2-SAT
words:
  - 洛谷P5782
  - P5782 题解：[POI 2001] 和平委员会
---

> [题目传送门](https://www.luogu.com.cn/problem/P5782)

# 题意分析

显然可以跑 2-SAT。

记 $f(x)$ 为 $x$ 的同一党派的代表。

那么，若 $i,j$ 彼此厌恶，建边 $i\rightarrow f(j),j\rightarrow f(i)$ 即可。

因为 $i$ 存在，则 $j$ 不存在，$f(j)$ 存在。$j\rightarrow f(i)$ 同理。

答案即在 $2i-1,2i$ 里选择拓扑序较大的，即 SCC 编号较小的。

# AC 代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=8000<<1;
int n;
vector<int>g[N<<2|1];
int dfn[N<<1|1],id[N<<1|1];
void Tarjan(int x){
	static int cnt,low[N<<1|1];
	static bool in[N<<1|1];
	static vector<int>s;
	dfn[x]=low[x]=++cnt;
	in[x]=true;
	s.push_back(x);
	for(int i:g[x]){
		if(!dfn[i]){
			Tarjan(i);
			low[x]=min(low[x],low[i]);
		}else if(in[i]){
			low[x]=min(low[x],dfn[i]);
		}
	}
	if(dfn[x]==low[x]){
		static int size=0;
		size++;
		while(s.back()!=x){
			in[s.back()]=false;
			id[s.back()]=size;
			s.pop_back();
		}
		in[s.back()]=false;
		id[s.back()]=size;
		s.pop_back();
	}
}
int f(int x){
	if(x&1){
		return x+1;
	}else{
		return x-1;
	}
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	int m;
	cin>>n>>m;
	n*=2;
	while(m--){
		int i,j;
		cin>>i>>j;
		g[i].push_back(f(j));
		g[j].push_back(f(i));
	}
	for(int i=1;i<=(n<<1);i++){
		if(!dfn[i]){
			Tarjan(i);
		}
	}
	for(int i=1;i<=n;i+=2){
		if(id[i]==id[i+1]||id[i]==id[i+n]){
			cout<<"NIE\n";
			return 0;
		}
	}
	for(int i=1;i<=n;i+=2){
		if(id[i]<id[i+1]){
			cout<<i<<'\n';
		}else{
			cout<<i+1<<'\n';
		}
	}
	
	cout.flush();
	 
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

