---
layout: post
title: "题解：[HAOI2015] 按位或"
subtitle: "洛谷P3175 | Min-max 容斥"
date: 2025-7-14
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 题解
  - 省选/NOI−
  - 数学
  - 组合数学
words:
  - Min-max容斥
  - 高维前缀和
---

>  [题目传送门](https://www.luogu.com.cn/problem/P3175)

# 题意分析

设 $t_i$ 表示第 $i$ 位变为 $1$ 的时间，设 $S=\lbrace1,2,3,\cdots,n\rbrace$。

则题目所求为：

$$
E\left(\max_{i\in S} t_i\right)
$$

期望套 $\max$，看起来就很像 Min-max 容斥。

由 Min-max 容斥，有：

$$
E\left(\max_{i\in S} t_i\right)=\sum_{T\subseteq S}(-1)^{\vert T\vert-1}E\left(\min_{i\in T}t_i\right)
$$

那么考虑如何求 $E\left(\min\limits_{i\in T}t_i\right)$。

记 $P(T)$ 表示为 $1$ 的位的集合为 $T$ 子集的概率，可用高位前缀和预处理。

考虑求 $\min\limits_{i\in T}t_i$ 的期望。假设 $\min\limits_{i\in T}t_i=k$ 求这种情况的出现概率即可。记 $\overline{T}$ 为 $T$ 的**补集**。

则，其出现概率为：

$$
P\left(\overline T\right)^{k-1}\left(1-P\left(\overline T\right)\right)
$$

有：
$$
\begin{aligned}
E(\min_{i\in T}t_i)&=\sum_{k=0}^{\infty}k\cdot P\left(\overline T\right)^{k-1}\left(1-P\left(\overline T\right)\right)\\
&=\sum_{k=0}^\infty k\\
&=\dfrac{1-P\left(\overline T\right)}{\left(1-P\left(\overline T\right)\right)^2}\\
&=1-P\left(\overline T\right)
\end{aligned}
$$

因此，$\mathcal O\left(2^n\right)$ 枚举 $T$，计算贡献即可。

# AC 代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=20;
int n;
double s[1<<N];
int popcount(int n){
	int ans=0;
	while(n){
		ans++;
		n-=n&-n;
	}
	return ans;
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n;
	for(int i=0;i<(1<<n);i++){
		cin>>s[i];
	}
	for(int i=0;i<n;i++){
		for(int j=0;j<(1<<n);j++){
			if(j&(1<<i)){
                //s[j] 表示 s[j] 的子集出现的概率
				s[j]+=s[j-(1<<i)];
			}
		}
	}
	double ans=0;
	for(int i=0;i<(1<<n)-1;i++){
        //一直会出现
		if(s[i]==1){
			cout<<"INF\n";
			return 0;
		}
		double pl=1/(1-s[i]);
		if(((n-popcount(i))&1)==0){
			pl=-pl;
		}
		ans+=pl;
	}
	cout.setf(ios::fixed);
	cout.precision(7);
	cout<<ans<<'\n';
	
	cout.flush(); 
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

