---
layout: post
title: "题解：未命名 1"
subtitle: "题目见正文|题目名称真的长这样！"
date: 2024-10-23
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 题解
  - 数学
  - 搜索
  - 扫描线
  - 二维数点
---

关于题目名称：

![](https://cfyy.us.kg/img/2024/10/020.png)

***

## 题目

> | 时间限制 | 空间限制 |  输入文件名  |  输出文件名   |
> | :------: | :------: | :----------: | :-----------: |
> | $3000ms$ | $256MB$  | `unnamed.in` | `unnamed.out` |

### 题目背景

"Never gonna give you up~"

"Never gonna let you down~"

### 题目描述

定义一个数 $a$ 是好的，当且仅当存在非负整数 $x,y(y>1)$ 使得 $a=x^y$。

给定 $T$，有 $T$ 组询问，每次给定 $a,b,c,d$，你需要求出满足以下条件的数对 $(i,j)$ 的个数：

* $a\leq i \leq b$
* $c\leq j \leq b$

* $\text{lcm}(i,j)$ 是好的，其中 $\text{lcm}(i,j)$ 表示 $i,j$ 的最小公倍数

### 输入格式

从 `unnamed.in` 读入数据。

第一行一个整数 $T$。

接下来 $T$ 行，每行 $4$ 个整数 $a,b,c,d$。

### 输出格式

输出到文件 `unnamed.out` 中。

一共 $T$ 行，表示每个询问的答案。

### 输入输出样例

#### 输入 #1

```
3
1 2 1 2
1 5 1 5
1 10 1 10
```

#### 输出 #1

```
1
6
20
```

### 说明/提示

**请使用较快的读入方式。**

对于 $40\%$ 的数据，$1\leq T \leq 10^6,1\leq a\leq b\leq10^3,1\leq c\leq d\leq 10^3$。

对于另外 $10\%$ 的数据，$1\leq T\leq 10^6,a=b=1,1\leq c\leq d\leq 10^6$。

对于另外 $20\%$ 的数据，$T=1,1=a\leq b\leq10^5,1=c\leq d\leq10^5$。

对于 $100\%$ 的数据，$1\leq T\leq10^6,1\leq a\leq b\leq10^6,1\leq c\leq d\leq10^6$。

#### 附件

[ex_unnamed.zip](https://cfyy.us.kg/file/2024/10/ex_unnamed.zip)

# 题解

### 前置知识：二维数点

参见[离线扫描线二位数点](https://cfyy.us.kg/2024/10/23/3/)。

### 题意分析

首先，假设我们已经找出了所有的合法数对 $(i,j)$。

那么明显对于答案，二维数点即可，时间复杂度 $\mathcal O(n+T)\log_2V$，其中 $n$ 是点的个数，$V$ 是值域。



# AC代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std; 
typedef long long ll;
#define int long long
const ll N=1e6,T=1e6;
struct problem{
	int l,r,id,value;
};
vector<problem>q[N+1];
int ans[T+1];
int top,p[N+1];
int gcd(int a,int b){
	if(b==0)return a;
	return gcd(b,a%b);
}
vector<int>a[N+1];
int cnt=0;
void dfs(int x,int y,int g,int lst){
	if(lst<=top&&x*p[lst]*p[lst]>N&&y*p[lst]*p[lst]>N){
		cnt++;
		a[x].push_back(y);
		return;
	}
	for(int i=0,pi=x;pi<=N;i++,pi*=p[lst]){
		for(int j=0,pj=y;pj<=N;j++,pj*=p[lst]){
			int pl=gcd(g,max(i,j));
			if(pl>1||i==0&&j==0)dfs(pi,pj,pl,lst+1);
		}
	}
}
void Start(){
	static bool vis[N+1];
	for(int i=2;i<=N;i++){
		if(!vis[i]){
			p[++top]=i;
			vis[i]=true;
			for(int j=i;j<=N;j+=i)vis[j]=true;
		}
	}dfs(1,1,0,1);
}
int t[N+1];
int lowbit(int x){
	return x&-x;
}
void add(int x,int k){
	while(x<=N){
		t[x]+=k;
		x+=lowbit(x);
	}
}
int query(int x){
	int ans=0;
	while(x){
		ans+=t[x];
		x-=lowbit(x);
	}return ans;
}
signed main(){
	freopen("unnamed.in","r",stdin);
	freopen("unnamed.out","w",stdout);
	
	Start();
	int t;
	scanf("%lld",&t);
	for(int i=1;i<=t;i++){
		int a,b,c,d;
		scanf("%lld %lld %lld %lld",&a,&b,&c,&d);
		q[a-1].push_back({c,d,i,-1});
		q[b].push_back({c,d,i,1});
	}
	for(int i=1;i<=N;i++){
		for(int j=0;j<a[i].size();j++)add(a[i][j],1);
		for(int j=0;j<q[i].size();j++){
			ans[q[i][j].id]+=q[i][j].value*(query(q[i][j].r)-query(q[i][j].l-1));
		}
	}
	for(int i=1;i<=t;i++)printf("%lld\n",ans[i]); 
	
	fclose(stdin); 
	fclose(stdout);
	return 0;
}
```

