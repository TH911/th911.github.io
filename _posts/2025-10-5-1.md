---
layout: post
title: "题解：再见绘梨"
subtitle: "题目见正文"
date: 2025-9-27
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 题解
  - 组合数学
  - 斯特林数
words:
  - Stirling
published: false
---

> |    时间限制     |    空间限制     | 输入文件名 | 输出文件名 |
> | :-------------: | :-------------: | :--------: | :--------: |
> | $\text{2000ms}$ | $\text{1000MB}$ |  `eri.in`  | `eri.out`  |

# 题目

## 题目描述

绘梨有 $n$ 部想看的电影，她计划要每天和优太看几部。但他们作为具有精致电影品味的人，有如下几点要求：

- 绘梨不喜欢单调的生活，因此一天不能多次看同一部电影，也不能存在两天看的电影集合相同。
- 优太说，「***Einmal ist keinmal.***」 故每部电影都要至少看两次！
- 可以存在某一天不看电影

作为吸血鬼的绘梨的寿命极长，对她来说每天的顺序，或是一天内看电影的顺序已是无法区分的了，我们只关心对于每个电影集合，是否存在一天恰好看了这些电影。

请你帮她求出在这样情况下不同的计划数有多少种吧，因为答案过大，请对 $p$ 取模。

## 输入格式

从文件 `eri.in` 中读入数据。

输入的第一行包含两个正整数 $n,p$，分别表示电影数和模数。

## 输出格式

输出到文件 `eri.out` 中。

输出一行包含一个非负整数，表示对应的答案。

## 输入输出样例

### 输入 #1

```
3 909119191
```

### 输出 #1

```
118
```

### 输入 #2

```
13 799013899
```

### 输出 #2

```
276433888
```

### 输入 #3

```
27 795914059
```

### 输出 #3

```
313670938
```

### 输入 #4

```
44 659330953
```

### 输出 #4

```
141039422
```

### 输入 #5

```
138 626280581
```

### 输出 #5

```
34671454
```

### 输入 #6

```
451 821055149
```

### 输出 #6

```
40423364
```

### 输入 #7

```
721 860784247
```

### 输出 #7

```
495459832
```

### 输入 #8

```
1020 620616151
```

### 输出 #8

```
294998395
```

### 输入 #9

```
202 859461851
```

### 输出 #9

```
689792092
```

### 输入 #10

```
526 985542031
```

### 输出 #10

```
433820960
```

### 输入 #11

```
107 571645663
```

### 输出 #11

```
196649017
```

## 说明/提示

### 数据范围

对于 $100\%$ 的数据保证，$2\leq n\leq5\times10^3,5\times10^8\leq p\leq10^9$，且 $p$ 为质数。

| 测试点编号 |    $n$     |
| :--------: | :--------: |
|   $1,2$    |  $\leq 4$  |
|  $3\sim5$  |  $\leq15$  |
| $6\sim10$  |  $\leq50$  |
| $10\sim14$ | $\leq500$  |
| $15\sim25$ | $\leq5000$ |

# 题解

> 对每个元素至少出现 $2$ 次的限制进行容斥，计算钦定确定的 $k$ 个数出现 $\leq 1$ 的方案数 $f_k$，最终答案为 $\displaystyle\sum_{k=0}^n(-1)^k\binom{n}{k}f_k$。不妨设这 $k$ 个元素是 $1\sim k$，那么 $S\subseteq[k+1,n]$ 可以任选是否出现，贡献为 $2^{2^{n-k}}$，对 $2^{n-k}$ 使用欧拉定理，即对 $p-1$ 取模，或者直接递推也是可行的。
>
> 这 $k$ 个元素至多会出现在 $m$ 个集合中，仅考虑这 $k$ 个元素内部的情况，求方案数 $g_{k,m}$。注意这 $k$ 个元素可以有不出现的，则 $\displaystyle f_k=\sum_{i=0}^kg_{k,i}2^{(n-k)i}$。而 $g$ 考虑直接递推：$g_{k,m}=g_{k-1,m-1}+g_{k-1,m}(m+1)$，比较类似于斯特林数的递推。时间复杂度 $\mathcal O(n^2)$。

设 $n$ 个元素都出现至少两次的答案为 $\textit{ans}_n$。

每一部电影都至少看 $2$ 次，对此进行容斥，设确定的 $k$ 个数出现次数都少于 $2$ 的方案数为 $f_k$，通过容斥基本原理计算，则有：

$$
\textit{ans}_n=\sum_{k=0}^n(-1)^k\dbinom nkf_k
$$

对于剩余的 $n-k$ 个元素，可以任意选择，共有 $2^{2^{n-k}}$ 种情况（$2^{n-k}$ 种集合）。

这 $k$ 个元素内部出现在 $i$ 个集合中。则有方案数为第二类斯特林数 $2^{i(n-k)}\begin{Bmatrix}k+1\\i+1\end{Bmatrix}$，即将 $k+1$ 个元素划分为 $i+1$ 个非空子集（对应一个空元素）。

故，最终答案为：
$$
\sum_{k=0}^n(-1)^k2^{2^{n-k}}\dbinom nk\left(\sum_{i=0}^k2^{i(n-k)}
\begin{Bmatrix}
k+1\\i+1
\end{Bmatrix}
\right)
$$

## AC 代码

注意变量取模的常数影响，需要使用 Barrett 约减。以及可能需要预处理 $2$ 的幂次。

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=5e3;
typedef long long ll;
typedef __int128 lll;
struct Barrett{
	ll p,m;
	inline void build(int P){
		p=P;
		m=((lll)1<<64)/p;
	}
	inline ll operator ()(ll x){
		ll ans=x-((lll)x*m>>64)*p;
		if(ans>=p){
			ans-=p;
		}
		return ans;
	}
}Barrett;
int n,P,pow2[N*N+1],pow2_[N+1];
int qpow(int base,int n){
	int ans=1;
	while(n){
		if(n&1){
			ans=Barrett(1ll*ans*base);
		}
		base=Barrett(1ll*base*base);
		n>>=1;
	}
	return ans;
}
int C(int n,int m){
	if(n<0||m<0||n<m){
		return 0;
	}
	if(!m){
		return 1;
	}
	static int mem[N+1][N+1];
	int &ans=mem[n][m];
	if(ans){
		return ans;
	}
	return ans=(C(n-1,m)+C(n-1,m-1))%P;
}
int S(int n,int k){
	if(n<0||k<0||n<k){
		return 0;
	}
	if(!k){
		return !n;
	}
	static int mem[N+1][N+1];
	int &ans=mem[n][k];
	if(ans){
		return ans;
	}
	return ans=(S(n-1,k-1)+1ll*k*S(n-1,k))%P;
}
signed main(){
	freopen("eri.in","r",stdin);
	freopen("eri.out","w",stdout);
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>P;
	Barrett.build(P);
	pow2[0]=pow2_[0]=1;
	for(int i=1;i<=n*n;i++){
		pow2[i]=Barrett(pow2[i-1]*2ll);
	}
	for(int i=1;i<=n;i++){
		pow2_[i]=pow2_[i-1]*2ll%(P-1);
	}
	int ans=0;
	for(int k=0;k<=n;k++){
		int w=1;
		if(k&1){
			w=-1;
		}
		w=Barrett(1ll*w*C(n,k)*qpow(2,pow2_[n-k]));
		for(int i=0;i<=k;i++){
			ans=Barrett(ans+Barrett(1ll*w*pow2[i*(n-k)])*S(k+1,i+1));
		}
	}
	if(ans<0){
		ans+=P;
	}
	cout<<ans<<'\n';
	
	cout.flush();
	 
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

