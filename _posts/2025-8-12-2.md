---
layout: post
title: "题解：[JOISC 2022] 监狱"
subtitle: "洛谷P9520"
date: 2025-8-12
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 题解
  - 省选/NOI−
  - 图论建模
  - 线段树优化建图
  - 未完
words:
 - "P9520 题解：[JOISC 2022] 监狱"
---

> [题目传送门](https://www.luogu.com.cn/problem/P9520)

# 朴素图论建模

记 $s_x,t_x$ 分别表示囚犯 $x$ 的起点、终点，$\set{s_x\rightarrow t_x}$ 表示囚犯 $x$ 走过的点集。

对于囚犯 $u,v$：

* 若 $s_u\in\set{s_v\rightarrow t_v}$，则 $u$ 比 $v$ 先走，否则会被挡住。
* 若 $t_u\in\set{s_v\rightarrow t_v}$，则 $v$ 比 $u$ 先走，否则会被挡住。

因此，考虑存储上述性质，考虑使用图。

新建一张图，图上**有向边** $u\rightarrow v$ 表示 $u$ 比 $v$ **先走**。

如果存在环，则无解。

否则，可行的解即按照拓扑序走动。

对于每一个囚犯 $x$，暴力查找其路径上的起点/终点对应囚犯，连边即可。

时间复杂度：$\mathcal O(nm)$。期望得分：$\text{72pts}$。特判链上情况可以做到 $\text{77pts}$。

## 参考代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=120000,M=N;
//s[i]:i 为起点的编号 
int n,m,s[N+1],t[N+1];
vector<int>g[N+1],build[M+1];
struct people{
	int s,t;
}a[M+1];
namespace base{
	int father[N+1],depth[N+1];
	void dfs(int x,int fx){
		depth[x]=depth[fx]+1;
		father[x]=fx;
		for(int i:g[x]){
			if(i==fx){
				continue;
			}
			dfs(i,x);
		}
	}
	int main(){
		dfs(1,0);
		return 0;
	}
	void clear(){
		for(int i=1;i<=n;i++){
			g[i].resize(0);
			build[i].resize(0);
		}
		memset(s,0,sizeof(s));
		memset(t,0,sizeof(t));
	}
}
void pre(){
	for(int i=1;i<=m;i++){
		int u=a[i].s,v=a[i].t;
		while(u!=v){
			if(base::depth[u]<base::depth[v]){
				swap(u,v);
			}
			if(s[u]&&s[u]!=i){
				build[s[u]].push_back(i);
			}
			if(t[u]&&t[u]!=i){
				build[i].push_back(t[u]);
			}
			u=base::father[u];
		}
		if(s[u]&&s[u]!=i){
			build[s[u]].push_back(i);
		}
		if(t[u]&&t[u]!=i){
			build[i].push_back(t[u]);
		}
	}
}
bool checkRing(){
	static int in[M+1];
	static bool vis[M+1];
	memset(in,0,sizeof(in));
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=m;i++){
		for(int j:build[i]){
			in[j]++;
		}
	}
	queue<int>q;
	for(int i=1;i<=m;i++){
		if(!in[i]){
			q.push(i);
		}
	}
	while(q.size()){
		int x=q.front();q.pop();
		vis[x]=true;
		for(int i:build[x]){
			in[i]--;
			if(!in[i]){
				q.push(i);
			}
		}
	}
	for(int i=1;i<=m;i++){
		if(!vis[i]){
			return true;
		}
	}
	return false;
} 
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	int T;
	cin>>T;
	while(T--){
		base::clear();
		cin>>n;
		for(int i=1;i<n;i++){
			int u,v;
			cin>>u>>v;
			g[u].push_back(v);
			g[v].push_back(u);
		}
		base::main();
		cin>>m;
		for(int i=1;i<=m;i++){
			cin>>a[i].s>>a[i].t;
			s[a[i].s]=i,t[a[i].t]=i;
		}
		pre();
		if(checkRing()){
			cout<<"No\n";
		}else{
			cout<<"Yes\n";
		}
	}
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
/*
2
7
1 2
2 3
3 4
4 5
3 6
6 7
2
4 1
5 7
4
1 2
1 3
1 4
3
2 3
3 4
4 2

Yes
No
*/
```

# 线段树优化建图

[参见此处](./Segment-Tree-Optmize-Graph)。



