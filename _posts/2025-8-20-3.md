---
layout: post
title: "题解：Trapmigiano Reggiano"
subtitle: "CF2071C"
date: 2025-8-20
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 题解
  - 普及+/提高
  - 贪心
words:
---

> [题目传送门](https://www.luogu.com.cn/problem/CF2071C)

# 题意分析

记起点为 $s$，终点为 $t$。

原树没有根，考虑人为设定一个根。不妨以 $t$ 为根节点。

那么求排列等价于求一种移动顺序，使得老鼠最后**停留在根节点**。

移动可以分两种：向上和向下。显然向上是**更优**的。

设老鼠当前位于节点 $p$，如果在 $x$ 处生成一个奶酪：

* 若 $x$ 是 $p$ 的祖先节点，则这是**优**的。
* 若 $x$ 是 $p$ 的子树内节点，则这是**劣**的。
* 否则 $x$ 仍然是**优**的，因为 $p$ 会走向 $\operatorname{lca}(x,p)$，会**向上**。

考虑先将子树内的走完，因此可以贪心：**先走深度大的节点**。

DFS 一遍，按照深度分类后从大到小输出即可。（BFS 也许可以更好求解，但是没必要。）

# AC 代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=1e5;
int n,s,t,depth[N+1];
vector<int>g[N+1],node[N+1];
void dfs(int x,int fx){
	depth[x]=depth[fx]+1;
	node[depth[x]].push_back(x);
	for(int i:g[x]){
		if(i==fx){
			continue;
		}
		dfs(i,x);
	}
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	int T;
	cin>>T;
	while(T--){
		for(int i=1;i<=n;i++){
			g[i].resize(0);
			node[i].resize(0);
		}
		cin>>n>>s>>t;
		for(int i=1;i<n;i++){
			int u,v;
			cin>>u>>v;
			g[u].push_back(v);
			g[v].push_back(u);
		}
		dfs(t,0);
		for(int i=n;i>=1;i--){
			for(int j:node[i]){
				cout<<j<<' ';
			}
		}
		cout<<'\n';
	}
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

