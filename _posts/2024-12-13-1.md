---
layout: post
title: "线段树详解"
subtitle: "例题：线段树1（P3372）、线段树2（P3373）"
date: 2024-12-13
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 题解
  - 普及+/提高
  - 线段树
words:
---

>  
>
> 之后很长一段时间都不会怎么深度碰 OI 了，防止哪天自己忘掉。
>
> [线段树1传送门](https://www.luogu.com.cn/problem/P3372)
>
> [线段树2传送门](https://www.luogu.com.cn/problem/P3373)

# 作用

> 线段树是算法竞赛中常用的用来维护**区间信息**的数据结构。
>
> 线段树可以在 $\mathcal O\left(\log n\right)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。

# 原理

> 虽然，我觉得叫“区间树”更为合理，然而几乎所有人都叫“线段树”......

以**区间和**为例。

初始时给出序列 $a[1...n]$。

## 基本结构

![](/img/2024/12/001.png)

如图，线段树将原区间 $[1,7]$ 拆成 $[1,4],[5,7]$，$[1,4]$ 又拆成 $[1,2],[3,4]$......直到拆成区间大小为 $1$。

### 存储

我们使用一个数组 $t$ 存储线段树。

那么对于每一个元素 $t[i]$ 维护一个区间，需要维护的值有 $l,r,sum,tag$，$sum$ 表示区间 $[l,r]$ 的和，$tag$ 见[懒标记](#懒标记)。

我们在 $t$ 上建一棵树。

令 $mid=\left\lfloor\dfrac{t[i].l+t[i].r}{2}\right\rfloor$，那么 $t[i]$ 的**左**子节点维护区间 $[l,mid]$ 的信息，**右**子节点维护区间 $[mid+1,r]$ 的信息。

现在的问题就是如何找到左右子节点。

考虑建一棵完全二叉树，那么我们对于 $t[i]$，仅仅需要访问 $t[i\times 2],t[i\times 2+1]$ 即可。

### 建树

树型结构，考虑递归。

定义递归函数 $build(p,l,r)$，表示 $t[p]$ 维护区间 $[l,r]$。

那么就有 $t[p].l=l,t[p].r=r$，而 $t[p].sum$ 即 $t[p\times 2].sum+t[p\times 2+1].sum$。

但是明显在执行 $build(p,l,r)$ 时，我们并不知道 $t[p\times2].sum,t[p\times2+1].sum$，因此我们需要先递归建出左右子树。

令 $mid=mid=\left\lfloor\dfrac{l+r}{2}\right\rfloor$ ，则先执行 $build(p\times 2,l,mid),build(p\times 2+1,mid+1,r)$。

那么递归边界如上图所述，即 $l=r$ 时，显然 $t[p].sum=a[l]$。

定义函数 $up(p)$，表示可以更新 $t[p]$，其内容就是 $t[p].sum=t[p\times 2].sum+t[p\times 2+1].sum$。

#### 参考代码

```cpp
void up(int p){
	t[p].sum=t[p*2].sum+t[p*2+1].sum;
}
void build(int p,int l,int r){
	t[p].l=l,t[p].r=r;
	if(l==r)t[p].sum=a[l];
	else{
		int mid=(l+r)/2;
		build(p*2,l,mid);
		build(p*2+1,mid+1,r);
		up(p);
	}
}
```

**注意：根节点为 $t[1]$**。

## 区间修改（区间加）

### 懒标记

懒标记是什么？

首先我们**不可能**在 $t$ 上找到所有的满足 $t[i].l=t[i].r \and l \leq t[i].l \leq r$ 的 $i$，然后去修改以后向上递归执行 $up(i)$ 一直到根节点 $1$——这样的效率甚至**不如**朴素 $\mathcal O(n)$。

因此引入了懒标记。

定义函数 $add(p,l,r,k)$ 表示将区间 $[l,r]$ 加上 $k$，$p$ 仍然作为 $t[p]$ 的下标，详见下文。

$add(p,l,r,k)$ 是递归执行的。

在递归的过程中，如果出现了 $t[p].l \leq l\leq r\leq t[p].r$，那么我们直接：

$$
t[p].sum\leftarrow t[p].sum+size(p)\times k,t[p].tag\leftarrow t[p].tag+k
$$

其中，$size(p)$ 表示区间 $\left[t[p].l,t[p].r\right]$ 的大小，具体而言就是 $size(p)=t[p].r-t[p].l+1$。

代码：

```cpp
int size(int p){
	return t[p].r-t[p].l+1;
}
```

解释一下 $t[p].tag$ 的含义：$t[p]$ 的左、右子树**未进行**的加法操作所需加的数，初始值为 $0$。

这样，$p$ 的子树便不需要继续递归。

那么复杂度为什么是 $\mathcal O\left(\log n\right)$ 呢？

首先，考虑到完全二叉树的性质，树高为 $\mathcal O\left(\log n\right)$。

先说结论：每一层至多访问 $4$ 个节点。

![](/img/2024/12/002.png)

如上。

关于正确性，考虑反证。假设能够访问到至少 $5$ 个节点。

则如图：

![](/img/2024/12/003.png)

根本不会访问到 $a,b$，因为在节点 $c$ 时便已经由于懒标记停止递归了。

***

如若 $t[p].l \leq l\leq r\leq t[p].r$ 不成立，我们就需要分别看看左右子树的覆盖区间是否与 $[l,r]$ 重合，重合了就递归，否则不执行。

### 懒标记下传

定义函数 $down(p)$ 来下传懒标记。

那么在 $add(p,l,r,k)$ 递归之前**一定要下传懒标记**。

因为在下传懒标记之前，其祖先的 $tag$ 不为 $0$，则该节点的 $sum$ 值是不可信的，而在 $add(p,l,r,k)$ 的最后会 $up(p)$ 来更新 $t[p]$ 加完之后**新的**区间和，因此子节点的 $sum$ 值必须是真实的，因此一定要下传。

区间和的懒标记下传也很简单，就是区间大小乘懒标记。

### 参考代码

```cpp
void down(int p){
	if(t[p].tag){
		t[2*p].sum+=size(2*p)*t[p].tag;
		t[2*p].tag+=t[p].tag;
		t[2*p+1].sum+=size(2*p+1)*t[p].tag;
		t[2*p+1].tag+=t[p].tag;
		t[p].tag=0; 
	}
}
void add(int p,int l,int r,int k){
	if(l<=t[p].l&&t[p].r<=r){
		t[p].sum+=size(p)*k;
		t[p].tag+=k;
	}else{
		down(p);
		if(l<=t[p*2].r)add(p*2,l,r,k);
		if(t[p*2+1].l<=r)add(p*2+1,l,r,k);
		up(p);
	}
}
```

