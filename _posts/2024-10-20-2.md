---
layout: post
title: "树上最近公共祖先（LCA）问题"
subtitle: "例题：洛谷P3379"
date: 2024-10-20
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - LCA
  - 普及/提高−
  - 倍增算法
  - DFS
  - 并查集
  - 在线算法
  - 离线算法
---

> 参考链接：[OI Wiki](https://oi-wiki.org/graph/lca/)

# 倍增LCA

## 倍增思想

可以参考[**ST表**](https://cfyy.us.kg/2024/10/20/3/#%E5%80%8D%E5%A2%9E%E6%80%9D%E6%83%B3)。

设 $\large f_{x,i}$ 表示 $x$ 的 $2^i$ 级祖先，用 $father_i$ 表示节点 $i$ 的父节点 ，则显然：
$$
\large f_{x,0}=father_x
$$
例如对于这棵树：

![](https://cfyy.us.kg/img/2024/10/014.png)

* $\large f_{9,0}=\normalsize father_9=6$。

* 节点 $9$ 的 $2^1$ 级祖先 $\large f_{9,1}=father_6=2$。

* 节点 $11$ 的 $2^2$ 级祖先：
  $$
  \begin{aligned}
  \large f_{11,2}&=\large 1\\
  &=\large f_{6,1}\\
  &=\large f_{f_{11,1},1}
  \end{aligned}
  $$

一个易于发现的事实是，**节点 $x$ 的 $2^i$ 级祖先是其 $2^{i-1}$ 级祖先的 $2^{i-1}$ 级祖先**。

那么状态转移方程为：
$$
\Large f_{x,i}=f_{f_{x,i-1},i-1}
$$

## 预处理

同[**ST表**](https://cfyy.us.kg/2024/10/20/3/#%E9%A2%84%E5%A4%84%E7%90%86)，代码很简单（$f[x][i]$ 同上文 $\large f_{x,i}$）：

```cpp
const int N=500000;
//邻接表
struct edge{
	int v,r;
}a[2*N+1];
//d:深度,h:链式前向星链头
int h[N+1],d[N+1],f[N+1][(int)log2(N)+1],lg[N+1];
//邻接表建边
void create(int u,int v){
	static int top=0;
	a[++top]={v,h[u]};
	h[u]=top;
}
//q:p的父节点 
void dfs(int p,int q){
	//基本信息 
	f[p][0]=q;//2^0=1,即p的父节点,q 
	d[p]=d[q]+1;//下一层 
	for(int i=h[p];i>0;i=a[i].r){
		if(a[i].v!=q)dfs(a[i].v,p);
	}
}
void lca_pre(){
	dfs(s,0);//s:树根
	for(int i=1;i<=n;i++)lg[i]=lg[i/2]+1;
	for(int i=1;i<=lg[n];i++){
		for(int x=1;x<=n;x++)f[x][i]=f[f[x][i-1]][i-1];
	}
}
```

时间复杂度：$\mathcal O(n\log_2 n)$。

## 查询

为了便于查找节点 $u,v$ 的最近公共祖先 $LCA(u,v)$，我们可以先使 $u,v$ 跳至同一高度（令 $d[u]>d[v]$），这时，我们便可以使用倍增算法 $\mathcal O(n\log_2n)$ 代替朴素 $\mathcal O(n)$ 向上跳。

类似于二进制，从 $2^{\log_2n+1}$ 到 $2^0$ 依次尝试，如果从 $u$ 跳至 $f[u][i]$ 满足 $d[f[u][i]] \geq d[v]$，那就可以从 $u$ 跳至 $f[u][i]$。

跳至同一高度后，再次倍增跳至相等的**下一层**，则 $LCA(u,v)=f[u][0]=f[v][0]$。（因为如果直接跳至 $u=v$，可能不是**最近**公共祖先）。

但是这样存在的问题就是，当 $v$ 为 $u$ 的祖先时，第一次跳完后便有 $u=v$，第二次倍增虽然不会跳，但是返回的 $f[u][0]$ 是**错误**答案。因此，在第一次倍增跳完后**加上特判**：`if(u==v)return u;`。

查询代码如下：

```cpp
int lca(int u,int v){
	if(d[u]<d[v])swap(u,v);
	for(int i=lg[d[u]-d[v]]-1;i>=0;i--){
		if(d[f[u][i]]>=d[v])u=f[u][i];
	}if(u==v)return u;
	for(int i=lg[d[u]]-1;i>=0;i--){
		if(f[u][i]!=f[v][i]){
			u=f[u][i];v=f[v][i];
		}
	}return f[u][0];
}
```

时间复杂度：$\mathcal O(\log_2n)$。

# 欧拉序+ST表

## 欧拉序是什么

DFS序的一种，但是DFS序只会在第一次访问的时候记录，而欧拉序无论访问还是回溯都需要记录。

比如这棵树的欧拉序：~~绝对不是我懒得画图~~

![](https://cfyy.us.kg/img/2024/10/014.png)

欧拉序为 $1,2,5,2,6,9,6,10,11,10,6,2,1,3,7,3,8,3,1,4$。

对于一棵节点数为 $n$ 的树，其欧拉序长度为 $2n-1$。因为共有 $n-1$ 条边，每条边访问两次会往欧拉序中加入两个节点，共计 $2n-2$ 个节点，再加上根节点，共计 $2n-1$ 个。

## 原理

令 $f_x$ 表示节点 $x$ 在欧拉序中第一次出现的位置。

那么：
$$
LCA(u,v)=\Large \min_{i=f_u}^{f_v}a_i
$$
其中，$a$ 为欧拉序，且 $f_u<f_v$（不然直接交换 $u,v$ 即可）。

那么这成为了一个RMQ问题，使用ST表求解即可。

关于其正确性，参考下图：

# DFS序+ST表

# Tarjan 离线算法（DFS+并查集）



# 练习题

[[NOIP2013 提高组] 货车运输](https://www.luogu.com.cn/problem/P1967)

https://www.luogu.com.cn/article/pu52m9ue

https://www.cnblogs.com/skip2004/p/12240164.html