---
layout: post
title: "树上最近公共祖先（LCA）问题"
subtitle: "例题：洛谷P3379"
date: 2024-10-20
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - LCA
  - 普及/提高−
  - 倍增算法
  - DFS
  - 并查集
  - ST表
  - RMQ
  - 在线算法
  - 离线算法
---

> 参考链接：[OI Wiki](https://oi-wiki.org/graph/lca/)

## 倍增LCA

### 倍增思想

可以参考[**ST表**](https://cfyy.us.kg/2024/10/20/3/#%E5%80%8D%E5%A2%9E%E6%80%9D%E6%83%B3)。

设 $\large f_{x,i}$ 表示 $x$ 的 $2^i$ 级祖先，用 $father_i$ 表示节点 $i$ 的父节点 ，则显然：

$$
\large f_{x,0}=father_x
$$

例如对于这棵树：

![](https://cfyy.us.kg/img/2024/10/014.png)

* $\large f_{9,0}=\normalsize father_9=6$。

* 节点 $9$ 的 $2^1$ 级祖先 $\large f_{9,1}=father_6=2$。

* 节点 $11$ 的 $2^2$ 级祖先：

  $$
  \begin{aligned}
  \large f_{11,2}&=\large 1\\
  &=\large f_{6,1}\\
  &=\large f_{f_{11,1},1}
  \end{aligned}
  $$

一个易于发现的事实是，**节点 $x$ 的 $2^i$ 级祖先是其 $2^{i-1}$ 级祖先的 $2^{i-1}$ 级祖先**。

那么状态转移方程为：

$$
\Large f_{x,i}=f_{f_{x,i-1},i-1}
$$

### 预处理

同[**ST表**](https://cfyy.us.kg/2024/10/20/3/#%E9%A2%84%E5%A4%84%E7%90%86)，代码很简单（$f[x][i]$ 同上文 $\large f_{x,i}$）：

```cpp
const int N=500000;
//邻接表
struct edge{
	int v,r;
}a[2*N+1];
//d:深度,h:链式前向星链头
int h[N+1],d[N+1],f[N+1][(int)log2(N)+1],lg[N+1];
//邻接表建边
void create(int u,int v){
	static int top=0;
	a[++top]={v,h[u]};
	h[u]=top;
}
//q:p的父节点 
void dfs(int p,int q){
	//基本信息 
	f[p][0]=q;//2^0=1,即p的父节点,q 
	d[p]=d[q]+1;//下一层 
	for(int i=h[p];i>0;i=a[i].r){
		if(a[i].v!=q)dfs(a[i].v,p);
	}
}
void lca_pre(){
	dfs(s,0);//s:树根
	for(int i=1;i<=n;i++)lg[i]=lg[i/2]+1;
	for(int i=1;i<=lg[n];i++){
		for(int x=1;x<=n;x++)f[x][i]=f[f[x][i-1]][i-1];
	}
}
```

时间复杂度：$\mathcal O(n\log_2 n)$。

### 查询

为了便于查找节点 $u,v$ 的最近公共祖先 $LCA(u,v)$，我们可以先使 $u,v$ 跳至同一高度（令 $d[u]>d[v]$），这时，我们便可以使用倍增算法 $\mathcal O(\log_2n)$ 代替朴素 $\mathcal O(n)$ 向上跳。

类似于二进制，从 $2^{\log_2n+1}$ 到 $2^0$ 依次尝试，如果从 $u$ 跳至 $f[u][i]$ 满足 $d[f[u][i]] \geq d[v]$，那就可以从 $u$ 跳至 $f[u][i]$。

跳至同一高度后，再次倍增跳至相等的**下一层**，则 $LCA(u,v)=f[u][0]=f[v][0]$。（因为如果直接跳至 $u=v$，可能不是**最近**公共祖先）。

但是这样存在的问题就是，当 $v$ 为 $u$ 的祖先时，第一次跳完后便有 $u=v$，第二次倍增虽然不会跳，但是返回的 $f[u][0]$ 是**错误**答案。因此，在第一次倍增跳完后**加上特判**：`if(u==v)return u;`。

查询代码如下：

```cpp
int lca(int u,int v){
	if(d[u]<d[v])swap(u,v);
	for(int i=lg[d[u]-d[v]]-1;i>=0;i--){
		if(d[f[u][i]]>=d[v])u=f[u][i];
	}if(u==v)return u;
	for(int i=lg[d[u]]-1;i>=0;i--){
		if(f[u][i]!=f[v][i]){
			u=f[u][i];v=f[v][i];
		}
	}return f[u][0];
}
```

时间复杂度：$\mathcal O(\log_2n)$。

## 欧拉序+ST表

### 欧拉序是什么

DFS序的一种，但是DFS序只会在第一次访问的时候记录，而欧拉序无论访问还是回溯都需要记录。

比如这棵树的欧拉序：~~绝对不是我懒得画图~~

![](https://cfyy.us.kg/img/2024/10/014.png)

欧拉序为 $1,2,5,2,6,9,11,9,6,10,6,2,1,3,7,3,8,3,1,4$。

对于一棵节点数为 $n$ 的树，其欧拉序长度为 $2n-1$。因为共有 $n-1$ 条边，每条边访问两次会往欧拉序中加入两个节点，共计 $2n-2$ 个节点，再加上根节点，共计 $2n-1$ 个。

### 原理

令 $f_x$ 表示节点 $x$ 在欧拉序中第一次出现的位置。

那么：

$$
LCA(u,v)=\Large \min_{i=f_u}^{f_v}o_i
$$

其中，$o_i$ 表示欧拉序中第 $i$ 项的深度，且 $f_u<f_v$（不然直接交换 $u,v$ 即可）。

那么这成为了一个RMQ问题，使用ST表求解即可。

关于其正确性，参考下图：

![](https://cfyy.us.kg/img/2024/10/015.png)

访问至 $u$ 后，会回溯至 $LCA(u,v)$，随即访问 $v$ 所在子树并最终访问至 $v$。

### 实现

#### 预处理

先DFS一遍维护基本信息，包括：

* 点 $x$ 的深度 $d_x$；
* 欧拉序第 $i$ 项的深度 $o_i$；
* 点 $x$ 在欧拉序中第一次出现的位置 $f_x$。

然后对 $o$ 进行ST表求最小值的预处理即可。

代码如下：

```cpp
const int N=500000,M=500000,N2=2*N; 
struct edge{
	int v,r;
}a[2*M+1];
int n,m,s,top,h[N+1],d[N+1],lg[N2+1],o[N2+1],st[N2+1][(int)log2(N2+1)+1],rest[N2+1][(int)log2(N2+1)+1],f[N+1];
void create(int u,int v){//链式前向星
	static int top=0;
	a[++top]={v,h[u]};
	h[u]=top;
}
void dfs(int p,int q){
	d[p]=d[q]+1;//深度
	o[++top]=p;//欧拉序
	if(f[p]==0)f[p]=top;//第一次出现的位置
	for(int i=h[p];i>0;i=a[i].r){
		if(a[i].v!=q){
			dfs(a[i].v,p);
			o[++top]=p;
		}
	}
}
void st_pre(){
	int n2=2*n-1;
	for(int i=0;i<=n2;i++)lg[i]=lg[i/2]+1;//常数优化
	for(int i=1;i<=top;i++){
		st[i][0]=d[o[i]];
		rest[i][0]=o[i]; 
	}
	for(int i=1;i<=lg[n2];i++){
		for(int x=1;x+(1<<i)-1<=n2;x++){
			st[x][i]=min(st[x][i-1],st[x+(1<<i-1)][i-1]);
			rest[x][i]=(st[x][i]==st[x][i-1]?rest[x][i-1]:rest[x+(1<<i-1)][i-1]);
		}
	}
}
void lca_pre(){
	dfs(s,0);
	st_pre();
}
```

时间复杂度：$\mathcal O(n\log_2n)$。

##### 注意事项

* 需要注意的是，维护ST表求区间最小值时，**还需要**维护一个数组记录 $st[x][i]$ 所对应的点 $rest[x][i]$。
* **ST表需要维护至欧拉序的长度 $2n-1$，而不是 $n$。**

#### 查询

这真的就没什么好说了，上代码：

```cpp
int lca(int u,int v){
	if(f[u]>f[v])swap(u,v);
	int s=log2(f[v]-f[u]+1);
	return (st[f[u]][s]<st[f[v]-(1<<s)+1][s]?rest[f[u]][s]:rest[f[v]-(1<<s)+1][s]);
}
```

时间复杂度：$\mathcal O(1)$。

## DFS序+ST表

***其实，实质上也可以说成压缩欧拉序。***

我们可以发现，“欧拉序+ST表”的解决方案预处理时，尽管时间复杂度为 $\mathcal O(n\log_2n)$，但常数较大。

**因为欧拉序长度为 $2n-1$。**

那么我们考虑在此基础上进行优化，可以发现欧拉序中会有重复的点，尝试去除这些点，由此，便有了此方案。

***同时，由于这是上一个方案的优化版本，并不会进行详细解释。***

同样对于这棵树：

![](https://cfyy.us.kg/img/2024/10/014.png)

其DFS序为：$1,2,5,6,9,11,10,3,7,8,4$，**长度为 $n$**。

设 $f_x$ 为节点 $x$ 在DFS序中的位置。

对于节点 $u,v$，不妨令 $f_u<f_v$（不然交换）。

考虑到 $u=v$ 时，直接返回 $u$ 作为答案，因此 $f_u<f_v$ 且 $u\ne v$。

1. $u$ 不为 $v$ 祖先时

   考虑DFS遍历时是先从 $LCA(u,v)$ 向下遍历至 $u$，随后回溯至 $LCA(u,v)$ 的包含 $v$ 的子树树根或其他子节点，再下行至 $v$。

   那么在区间 $[f_u,f_v]$ 中**任意**深度最小的点的父节点即 $LCA(u,v)$。

2. $u$ 为 $v$ 的祖先时

   显然，$LCA(u,v)=u$，且此时 $u$ 至 $v$ 为一条下行链。

   考虑到此时再在区间 $[f_u,f_v]$ 中查找深度最小节点，**必定查找到点 $u$**，使最终答案**不正确**。

   那么在区间 $[f_u+1,f_v]$ 中查找即可，因为这样**必定查找到 $f_u+1$ 对应点，其父节点即 $u$**。

   1.中**同样可以查询 $[f_u+1,f_v]$**，因为 $u$ 不为 $v$ 祖先时，$LCA(u,v)$ 不为 $u$，去除并不影响答案。

事实上，也可以查询区间 $[f_u+1,f_v-1]$，然而在ST表 $\mathcal O(1)$ 查询下，**这不重要**。

**查询**代码如下：

```cpp
int lca(int u,int v){
	if(u==v)return u;
	if(f[u]>f[v])swap(u,v);
	int s=log2(f[v]-(f[u]+1)+1);
	return father[(st[f[u]+1][s] < st[f[v]-(1<<s)+1][s] ? rest[f[u]+1][s] : rest[f[v]-(1<<s)+1][s])];
}
```

仅仅是多了一个 $father$ 数组表示父节点。

同时，**原本需要开至 $2n-1$ 大小的 $lg,st,rest$ 等数组可以只需要开 $n$ 个**。

**查询**时间复杂度：$\mathcal O(1)$。

## Tarjan 离线算法（DFS+并查集）

## 思想

先一次性读入所有的询问（所有的 $u_i,v_i$），再进行运算后一次性输出。



## 各种LCA算法的比较



## 练习题（参考代码）

### [【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

#### 倍增算法

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
const int N=500000;
//邻接表:链式前向星 
struct edge{
	int v,r;
}a[2*N+1];
//d[i]:节点i的深度(第几层),f[i][j]:节点i的2^j级祖先(向上寻找2^j次父节点) 
int n,m,s,x,y,h[N+1],d[N+1],f[N+1][32],lg[N+1];
//创建一条边(u,v) 
void create(int u,int v){
	static int top=0;
	a[++top]={v,h[u]};
	h[u]=top;
}
//q:p的父节点 
void dfs(int p,int q){
	//基本信息 
	f[p][0]=q;//2^0=1,即p的父节点,q 
	d[p]=d[q]+1;//下一层 
	for(int i=h[p];i>0;i=a[i].r){
		if(a[i].v!=q)dfs(a[i].v,p);
	}
}
void lca_pre(){
	dfs(s,0);
	for(int i=1;i<=n;i++)lg[i]=lg[i/2]+1;
	for(int i=1;i<=lg[n];i++){
		for(int x=1;x<=n;x++)f[x][i]=f[f[x][i-1]][i-1];
	}
}
int lca(int u,int v){
	if(d[u]<d[v])swap(u,v);
	for(int i=lg[d[u]-d[v]]-1;i>=0;i--){
		if(d[f[u][i]]>=d[v])u=f[u][i];
	}if(u==v)return u;
	for(int i=lg[d[u]]-1;i>=0;i--){
		if(f[u][i]!=f[v][i]){
			u=f[u][i];v=f[v][i];
		}
	}return f[u][0];
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	scanf("%d %d %d",&n,&m,&s);
	for(int i=1;i<n;i++){
		scanf("%d %d",&x,&y);
		create(x,y);create(y,x);
	}lca_pre(); 
	while(m--){
		scanf("%d %d",&x,&y);
		printf("%d\n",lca(x,y));
	}
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

#### 欧拉序+ST表

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
const int N=500000,M=500000,N2=2*N; 
struct edge{
	int v,r;
}a[2*M+1];
int n,m,s,top,h[N+1],d[N+1],lg[N2+1],o[N2+1],st[N2+1][(int)log2(N2+1)+1],rest[N2+1][(int)log2(N2+1)+1],f[N+1];
void create(int u,int v){
	static int top=0;
	a[++top]={v,h[u]};
	h[u]=top;
}
void dfs(int p,int q){
	d[p]=d[q]+1;
	o[++top]=p;
	if(f[p]==0)f[p]=top;
	for(int i=h[p];i>0;i=a[i].r){
		if(a[i].v!=q){
			dfs(a[i].v,p);
			o[++top]=p;
		}
	}
}
void st_pre(){
	int n2=2*n-1;
	for(int i=0;i<=n2;i++)lg[i]=lg[i/2]+1;
	for(int i=1;i<=top;i++){
		st[i][0]=d[o[i]];
		rest[i][0]=o[i]; 
	}
	for(int i=1;i<=lg[n2];i++){
		for(int x=1;x+(1<<i)-1<=n2;x++){
			st[x][i]=min(st[x][i-1],st[x+(1<<i-1)][i-1]);
			rest[x][i]=(st[x][i]==st[x][i-1]?rest[x][i-1]:rest[x+(1<<i-1)][i-1]);
		}
	}
}
void lca_pre(){
	dfs(s,0);
	st_pre();
}
int lca(int u,int v){
	if(f[u]>f[v])swap(u,v);
	int s=log2(f[v]-f[u]+1);
	return (st[f[u]][s]<st[f[v]-(1<<s)+1][s]?rest[f[u]][s]:rest[f[v]-(1<<s)+1][s]);
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	scanf("%d %d %d",&n,&m,&s);
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%d %d",&x,&y);
		create(x,y);create(y,x);
	}lca_pre(); 
	while(m--){
		int x,y;
		scanf("%d %d",&x,&y);
		printf("%d\n",lca(x,y));
	}
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

#### DFS序+ST表

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
const int N=500000,M=500000; 
struct edge{
	int v,r;
}a[2*M+1];
int n,m,s,top,h[N+1],d[N+1],lg[N+1],o[N+1],st[N+1][(int)log2(N+1)+1],rest[N+1][(int)log2(N+1)+1],f[N+1],father[N+1];
void create(int u,int v){
	static int top=0;
	a[++top]={v,h[u]};
	h[u]=top;
}
void dfs(int p,int q){
	father[p]=q;
	d[p]=d[q]+1;
	o[++top]=p;
	if(f[p]==0)f[p]=top;
	for(int i=h[p];i>0;i=a[i].r){
		if(a[i].v!=father[p])dfs(a[i].v,p);
	}
}
void st_pre(){
	for(int i=0;i<=n;i++)lg[i]=lg[i/2]+1;
	for(int i=1;i<=top;i++){
		st[i][0]=d[o[i]];
		rest[i][0]=o[i]; 
	}
	for(int i=1;i<=lg[n];i++){
		for(int x=1;x+(1<<i)-1<=n;x++){
			st[x][i]=min(st[x][i-1],st[x+(1<<i-1)][i-1]);
			rest[x][i]=(st[x][i]==st[x][i-1]?rest[x][i-1]:rest[x+(1<<i-1)][i-1]);
		}
	}
}
void lca_pre(){
	dfs(s,0);
	st_pre();
}
int lca(int u,int v){
	if(u==v)return u;
	if(f[u]>f[v])swap(u,v);
	int s=log2(f[v]-(f[u]+1)+1);
	return father[(st[f[u]+1][s] < st[f[v]-(1<<s)+1][s] ? rest[f[u]+1][s] : rest[f[v]-(1<<s)+1][s])];
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	scanf("%d %d %d",&n,&m,&s);
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%d %d",&x,&y);
		create(x,y);create(y,x);
	}lca_pre(); 
	while(m--){
		int x,y;
		scanf("%d %d",&x,&y);
		printf("%d\n",lca(x,y));
	}
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

#### Tarjan 离线算法（DFS+并查集）



### [[NOIP2013 提高组] 货车运输](https://www.luogu.com.cn/problem/P1967)

#### 思路分析

让每一辆车的载重限制都尽可能大，在图上建**最大生成树**，然后树上求LCA即可。（本处仅给出**倍增算法**的参考代码）

#### 参考代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
const int N=1e4,M=5e4;
struct edge{
	int u,v,w;
}x[M+1];
struct edge_tree{
	int v,r,w;
}a[2*M+1];
int n,m,u,v,w,q,f[N+1],h[N+1],lg[N+1],d[N+1],pl[N+1][31],dis[N+1][31];
bool vis[N+1];
void create(int u,int v,int w){
	static int top=0;
	a[++top]={v,h[u],w};
	h[u]=top;
}
int find(int x){
	if(f[x]!=x)return f[x]=find(f[x]);
	return x;
}
void unite(int x,int y){
	f[find(x)]=find(y);
}
bool cmp(edge a,edge b){
	return a.w>b.w;
}
void Kruskal(){
	sort(x+1,x+m+1,cmp);
	for(int i=1;i<=n;i++)f[i]=i;
	for(int i=1,cnt=0;i<=m&&cnt<n-1;i++){
		if(find(x[i].u)!=find(x[i].v)){
			unite(x[i].u,x[i].v);
			create(x[i].u,x[i].v,x[i].w);
			create(x[i].v,x[i].u,x[i].w);
		}
	}
}
void dfs(int p,int q,int w){
	vis[p]=true;
	pl[p][0]=q;
	dis[p][0]=w;
	d[p]=d[q]+1;
	for(int i=1;i<=lg[d[p]];i++){
		pl[p][i]=pl[pl[p][i-1]][i-1];
		dis[p][i]=min(dis[p][i-1],dis[pl[p][i-1]][i-1]);
	}for(int i=h[p];i>0;i=a[i].r){
		if(a[i].v!=q)dfs(a[i].v,p,a[i].w);
	}
}
int lca(int u,int v){
	if(find(u)!=find(v))return -1;
	int ans=2147483647;
	if(d[u]<d[v])swap(u,v);
	while(d[u]>d[v]){
		ans=min(ans,dis[u][lg[d[u]-d[v]]-1]);
		u=pl[u][lg[d[u]-d[v]]-1];
	}if(u==v)return ans;
	for(int i=lg[d[u]]-1;i>=0;i--){
		if(pl[u][i]!=pl[v][i]){
			ans=min(ans,min(dis[u][i],dis[v][i]));
			u=pl[u][i];
			v=pl[v][i];
		}
	}ans=min(ans,min(dis[u][0],dis[v][0]));
	return ans;
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++)scanf("%d %d %d",&x[i].u,&x[i].v,&x[i].w);
	Kruskal();
	for(int i=1;i<=n;i++)lg[i]=lg[i/2]+1;
	for(int i=1;i<=n;i++){
		if(vis[i]==false)dfs(i,0,0);
	}
	scanf("%d",&q);
	while(q--){
		scanf("%d %d",&u,&v);
		printf("%d\n",lca(u,v));
	}
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```
