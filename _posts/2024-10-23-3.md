---
layout: post
title: "离线扫描线二维数点"
subtitle: "例题：洛谷P10814"
date: 2024-10-23
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 离线算法
  - 扫描线
  - 二维数点
---

## 什么是二维数点

顾名思义，在一个二维平面内求一个矩形内有多少个点（“点”并非指普通几何点，否则有无数个），如图。

![](https://cfyy.us.kg/img/2024/10/021.png)

我们可以一眼看出：

* $\color{red}\colorbox{red}{1}$ 矩形内有 $1$ 个点；
* $\color{#FF8000}\colorbox{#FF8000}{1}$ 矩形内有 $1$ 个点；
* $\color{#3F48CC}\colorbox{#3F48CC}{1}$ 矩形内有 $1$ 个点；
* $\color{#C3C3C3}\colorbox{#C3C3C3}{1}$ 矩形内没有点；

* $\color{#B97A57}\colorbox{#B97A57}{1}$ 矩形内有 $9$ 个点。

然而计算机不能如此一眼看出，那么找到矩形内点的数量的过程就是**二维数点**。

## 扫描线算法

思想如图（来源于[OI Wiki](https://oi-wiki.org/geometry/scanning/#%E4%BA%8C%E7%BB%B4%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E5%B9%B6%E9%97%AE%E9%A2%98)）：

![](https://cfyy.us.kg/img/2024/10/022.svg)

当然，此图展现的是扫描矩形面积并，而不是二维数点，但“点”其实也可以视为 $1\times 1$ 的矩形。

扫描线的底层逻辑就是模拟一条线扫描过去，最后给出答案。

### 问题形式

很有可能不是形如“给定二维平面，求某一矩形内符合要求的点的数量”，也有可能是“给一个长为 $n$ 的序列，有 $m$ 次查询，每次查区间 $[l,r]$ 中值在 $[x,y]$ 内的元素个数。”

### 过程

以“求 $[l,r]$ 区间中小于等于 $x$ 的元素个数”为例。

从左往右扫描，扫到了点便加入。

开一个**权值树状数组**，记录 $x$ 出现的次数。

给 $[l,r]$ 进行左右差分即可。

## （例题P10814）AC代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
const int N=2e6,M=2e6;
struct problem{
	int x,id,value;
};
vector<problem>q[M+1];
int n,m,a[N+1],t[N+1],ans[N+1];
//树状数组 
int lowbit(int x){
	return x&-x;
}
void add(int x,int k){
	while(x<=N){
		t[x]+=k;
		x+=lowbit(x);
	}
}
int query(int x){
	int ans=0;
	while(x){
		ans+=t[x];
		x-=lowbit(x);
	}return ans;
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",a+i);
	for(int i=1;i<=m;i++){
		int l,r,x;
		scanf("%d %d %d",&l,&r,&x);
		q[l-1].push_back({x,i,-1});
		q[r].push_back({x,i,1});
	}for(int i=1;i<=n;i++){
		add(a[i],1);
		for(int j=0;j<q[i].size();j++){
			ans[q[i][j].id]+=q[i][j].value*query(q[i][j].x);
		}
	}for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
	
	/*fclose(stdin); 
	fclose(stdout);*/
	return 0;
}
```

