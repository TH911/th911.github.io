---
layout: post
title: "题解：[CSP-S2019] Emiya 家今天的饭"
subtitle: "洛谷P5664"
date: 2025-8-16
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 题解
  - 提高+/省选−
  - DP
words:
---

> [题目传送门](https://www.luogu.com.cn/problem/P5664)

# 题意分析

原来的 $a$ 可以视为一个矩阵。接下来的「行」「列」即矩阵意义下的行/列，「行」代表「烹饪方法」，「列」代表「主要食材」。

不考虑小于等于 $$\left\lfloor\dfrac k2\right\rfloor$$ 的限制，不难发现，所有的方案数为：
$$
\prod_{i=1}^n\left(\sum_{j=1}^ma_{i,j}+1\right)-1
$$

直接求不好求，考虑用总方案数减去某一列大于 $\left\lfloor\dfrac k2\right\rfloor$ 的方案数。

发现列之间**互相独立**，且至多一列大于 $\left\lfloor\dfrac k2\right\rfloor$，因此枚举这一列，记为 $p$。

因此可以 DP，但是注意到直接 DP 会炸 TLE/MLE。

注意到具体是多少并不重要，我们只关心**是否大于** $\left\lfloor\dfrac k2\right\rfloor$，因此可以进行差分。即设 $\textit{dp}_{i,j}$ 表示前 $i$ 行，第 $p$ 列与其他列之和的差为 $j$ 时的方案数。

* 若第 $i$ 行不选，方案数为 $\textit{dp}_{i-1,j}$。
* 第 $i$ 行选择，不选第 $p$ 列，方案数为 $\textit{dp}_{i-1,j-1}\times a_{i,p}$。
* 第 $i$ 行选择，选择第 $p$ 列，方案数为 $\textit{dp}_{i-1,j+1}\left(\sum\limits_{l=1}^ma_{i,l}-a_{i,p}\right)$。

因此有：

$$
\textit{dp}_{i,j}=\textit{dp}_{i-1,j}+\textit{dp}_{i-1,j-1}\times a_{i,p}+\textit{dp}_{i-1,j+1}\left(\sum\limits_{l=1}^ma_{i,l}-a_{i,p}\right)
$$

则，第 $p$ 列大于 $\left\lfloor\dfrac k2\right\rfloor$ 的方案数为：

$$
\sum_{i=1}^n\textit{dp}_{n,i}
$$


# AC 代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef long long ll;
constexpr const int N=100,M=2000,P=998244353;
int n,m,a[N+1][M+1],sum[N+1],dp[N+1][M+1];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	int ans=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			sum[i]=(sum[i]+a[i][j])%P;
		}
		ans=1ll*ans*(sum[i]+1)%P;
	}
	ans--;
	for(int k=1;k<=m;k++){
		memset(dp,0,sizeof(dp));
		dp[0][n]=1;
		for(int i=1;i<=n;i++){
			for(int j=n-i;j<=n+i;j++){
				dp[i][j]=(dp[i-1][j]+1ll*dp[i-1][j-1]*a[i][k]+1ll*dp[i-1][j+1]*(sum[i]-a[i][k]))%P;
			}
		}
		for(int i=1;i<=n;i++){
			ans=(ans-dp[n][n+i])%P;
		}
	}
	if(ans<0){
		ans+=P;
	}
	cout<<ans<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

