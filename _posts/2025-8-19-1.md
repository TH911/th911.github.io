---
layout: post
title: "题解：[HNOI2004] 敲砖块"
subtitle: "洛谷P1437"
date: 2025-8-19
author: "TH911"
header-img: "img/2024/10/006.jpeg"
header-mask: 0.4
tags:
  - 题解
  - 提高+/省选−
  - DP
words:
---

> [题目传送门](https://www.luogu.com.cn/problem/P1437)

# 题意分析

发现一块砖 $(i,j)$ 被打掉之后，第 $j$ 列在 $i$ 上面的砖都会被打掉。

设 $\textit{dp}_{i,j,k}$ 表示第 $i$ 列中，打掉的最下面的砖为 $(j,i)$，一共打掉了 $k$ 块砖的答案。

则有：

$$
\textit{dp}_{i,j,k}=\max_{l=0}^{j+1}\textit{dp}_{i-1,l,k-j}+\sum_{l=1}^ja_{l,i}
$$

即枚举 $l$，使得第 $i-1$ 列打到了第 $l$ 行。且 $l\leq j+1$。这是为了保证第 $i-1$ 列**合法**，即能够包含 $i\sim n$ 列打掉的块。

# AC 代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=50,M=N*(N+1)>>1;
int n,m,a[N+1][N+1],dp[N+1][N+1][M+1];
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n-i+1;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=n;j++){
			for(int k=j;k<=m;k++){
				for(int l=0;l<=j+1;l++){
					dp[i][j][k]=max(dp[i][j][k],dp[i-1][l][k-j]);
				}
				for(int l=1;l<=j;l++){
					dp[i][j][k]+=a[l][i];
				}
			}
		} 
	}
	cout<<max(dp[n][0][m],dp[n][1][m])<<'\n';
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

